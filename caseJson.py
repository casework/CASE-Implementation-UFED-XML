#---	class CaseJson.py

import uuid
import os
import re

class CaseJson:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	C_TAB = '\t'
	C_NP = '_NOT_PROVIDED_'

	def __init__(self, fileOut, appName, appUserName, appUserAccount):
	# to be defined
		self.FileOut = fileOut
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []

		self.EMAILaccountIdList = []
		self.EMAILaddressList = []
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.U_ACCOUNTapp = appName
		self.U_ACCOUNTappUserName = appUserName
		self.U_ACCOUNTappUserAccount = appUserAccount

		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def ___generateContextUfed(self, ufedVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('UFED_PA', 'Acquisition', 
			'Cellebrite', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '');

		# generate Trace/Device for the mobile phone
		idDevice = self.__generateTraceDevice(deviceMacAddress, deviceId, devicePhoneModel,
			deviceOsType, deviceOsVersion, devicePhoneVendor, '',
			deviceIccid, deviceImsi, deviceImei, deviceBluetoothAddress)
		
		# generate Trace/Provenance_Record for the mobile device
		idDeviceList = []
		idDeviceList.append(idDevice)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			CaseJson.C_NP, deviceAcquisitionStartTime) 
		
		# generate Trace/File for each file extracted by the Acuisition action
		# idFileList contains the uuid of these files and it is used for
		# creating the Provenance_Record of the Result/Output of the Acquisition 
		# action
		idFilesAcquisition = []
		for i in range(len(imagePath)):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(imagePath[i], 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], CaseJson.C_NP, 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)  
				 
			else:
				idFileAcquisition = self.__generateTraceFile(imagePath[i], 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], CaseJson.C_NP, 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP) 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
        	'Acquisition files', CaseJson.C_NP, deviceAcquisitionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)
        
		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceAcquisitionStartTime, 
			deviceAcquisitionEndTime, idTool, CaseJson.C_NP, 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			CaseJson.C_NP, deviceExtractionStartTime);
        
		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceExtractionStartTime,
			CaseJson.C_NP, idTool, CaseJson.C_NP, idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, IdTrace, uuidTrace, endChar=','):
	    # search traceId in EXTRA_INFOdictNodeInfo a dictionary whose keys are the id
	    # that represents the link between a Trace and its file(s)
		table = self.EXTRA_INFOdictTableName.get(IdTrace, '_?TABLE')
		offset = self.EXTRA_INFOdictOffset.get(IdTrace, '_?OFFSET')
		# this is the case where the infoNode sub element of extraInfo contains the id 
	    # reference to the file. More then one infoNode can exist, the value of the key 
	    # contains the id file separated by @@
		if self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '').strip() == '':
			path = self.EXTRA_INFOdictPath.get(IdTrace, '_?PATH')
			size = self.EXTRA_INFOdictSize.get(IdTrace, '_?SIZE')
			uuidFile = self.__generateTraceFile(path, size, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP)

			self.FILEuuid[IdTrace] = uuidFile
			self.__generateTraceRelation(uuidTrace, uuidFile, 'contained_within', 
				table, offset);
		else:
			nodeInfoIdList = self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '@@@').split('@@@')
			for node in nodeInfoIdList:
				if node.strip() != '':
					if node in self.FILEid: 
						#idFile = self.FILEid.index(node)
						#uuid = FILEuuid.get(idFile, '_?UUID')
						uuidFile = self.FILEuuid.get(node, '_?UUID')
						self.__generateTraceRelation(uuidTrace, uuidFile, 'contained_within', 
							table, offset);
					else:
						print ('nodeInfo ' + node + ' not found')
		


	def __generateHeader(self):
		uuid = CaseJson.__createUUID()
		line = "".join(['{ \n', \
				CaseJson.C_TAB + '"@context": { \n', \
				CaseJson.C_TAB*2 + '"@vocab": "http://caseontology.org/core#", \n', \
				CaseJson.C_TAB*2 + '"case-investigation": "https://caseontology.org/ontology/case/investigation#", \n', \
				CaseJson.C_TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n', \
				CaseJson.C_TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n', \
				CaseJson.C_TAB*2 + '"uco-action": "https://unifiedcyberontology.org/ontology/uco/action#", \n', \
				CaseJson.C_TAB*2 + '"uco-core": "https://unifiedcyberontology.org/ontology/uco/core#", \n', \
				CaseJson.C_TAB*2 + '"uco-identity": "https://unifiedcyberontology.org/ontology/uco/identity#",\n', \
				CaseJson.C_TAB*2 + '"uco-location": "https://unifiedcyberontology.org/ontology/uco/location#",\n', \
				CaseJson.C_TAB*2 + '"uco-observable": "https://unifiedcyberontology.org/ontology/uco/observable#", \n', \
				CaseJson.C_TAB*2 + '"uco-tool": "https://unifiedcyberontology.org/ontology/uco/tool#", \n', \
				CaseJson.C_TAB*2 + '"uco-types": "https://unifiedcyberontology.org/ontology/uco/types#", \n', \
				CaseJson.C_TAB*2 + '"uco-vocabulary": "https://unifiedcyberontology.org/ontology/uco/vocabulary#", \n', \
				CaseJson.C_TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n', \
				CaseJson.C_TAB*2 + '},\n', \
				'"@id": ":bundle-' + uuid + '", \n', \
				'"@type": "uco-core:Bundle",\n', \
				'"uco-core:specVersion": "CASE 0.2 - UCO 0.4",\n', \
				'"uco-core:description": "Extraction from XML report generated by UFED PA",\n', \
				'"uco-core:object": [\n'])
		self.FileOut.write(line)

	def __generateLastLine(self):
		line = CaseJson.C_TAB + '] \n }'
		self.FileOut.write(line)

	def __generateTraceAppAccount(self, source, name, identifier, idApp, idIdentity):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[ \n', \
			CaseJson.C_TAB*2 + '{ \n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:Account", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + idIdentity + '", \n'
			CaseJson.C_TAB*3 + '"uco-observable:accountIdentifier":"' + identifier + '", \n' , \
			CaseJson.C_TAB*3 + '"uco-observable:isActive":"true" \n', \
			CaseJson.C_TAB*2 + '}, \n', \
			CaseJson.C_TAB*2 + '{ \n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:ApplicationAccount", \n' , \
			CaseJson.C_TAB*3 + '"uco-observable:application":\n', \
			CaseJson.C_TAB*4 + '{\n', \
			CaseJson.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			CaseJson.C_TAB*4 + '}\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '{ \n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:DigitalAccount", \n', \
			CaseJson.C_TAB*3 + '"uco-observable:displayName":"' + name + '"\n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + ']\n', \
			'}, \n'])
		self.FileOut.write(line);
		return uuid
	
	def __generateTraceAppName(self, appName):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
		# aligned wit CASE version 0.4
		#line += CaseJson.C_TAB + '"uco-core:name":"' + appName + '",\n'
			CaseJson.C_TAB + '"uco-core:facets":[ \n', \
			CaseJson.C_TAB*2 + '{ \n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Application", \n', \
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:out property in Observable
#		
		#line += CaseJson.C_TAB*2 + '"uco-core:proposed:appName": "' + appName + '"\n'
			CaseJson.C_TAB*2 + '"uco-core:name": "' + appName + '"\n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:Identity", \n', \
			CaseJson.C_TAB + '"uco-core:facets":[ \n', \
			CaseJson.C_TAB*2 + '{ \n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Organization", \n', \
			CaseJson.C_TAB*2 + '"uco-observable:orgName":"' + appName + '" \n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line);
		return uuid


	def __generateTraceCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM):
		for i in range(len(CALLid)):
			# Only traditional, normal phone call are processed: UFED possible values are those
			# those indicated below
			if (CALLsource[i].strip() == '' or 
				CALLsource[i].strip().lower() == 'call' or
				CALLsource[i].strip().lower() == 'native call log'): 
				if CALLdirection[i].lower() == 'incoming':
					if (len(CALLnamesFROM[i]) > 0): 
						nameParty = CALLnamesFROM[i][0]
					else:
						nameParty = CaseJson.C_NP

					if (len(CALLidentifiersFROM[i]) > 0): 
						idParty = CALLidentifiersFROM[i][0]
					else:
						idParty = CaseJson.C_NP											
				else:
					if (len(CALLnamesTO[i]) > 0):
						nameParty = CALLnamesTO[i][0]
					else:
						nameParty = CaseJson.C_NP	

					if (len(CALLidentifiersTO[i]) > 0):
						idParty = CALLidentifiersTO[i][0]					
					else:
						idParty = CaseJson.C_NP	

				# if the identifier of the Call is empty, no CASE object is generated.
				# Some Calls do not have any info on identifier with role TO/FROM
				if idParty.strip() == '':
					continue
				
				if idParty in self.phoneNumberList:
					idx = self.phoneNumberList.index(idParty)
					#userId = self.phoneNumberList[idx]
					uuid = self.phoneUuidList[idx]
				else:	
# if the mobile operator will be available in the XML report, it will be possible to 	
#	define an object uco-identity:Identity related to the organisation. At the moment
# the varibale is set to empty, so no the property uco-observable:accountIssuer is not 
# included in the	uco-observable:PhoneAccount				
					mobileOperator = ""
					uuid = self.__generateTracePhoneAccount(mobileOperator, 
						nameParty, idParty)
				
				if CALLdirection[i].lower() == 'incoming':
					uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
						CALLtimeStamp[i], self.phoneOwnerUuid, uuid, CALLduration[i],
	                           CALLstatus[i], CALLoutcome[i])
				else:
					uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
						CALLtimeStamp[i], uuid, self.phoneOwnerUuid, CALLduration[i],
	                           CALLstatus[i], CALLoutcome[i])
				self.__generateChainOfEvidence(CALLid[i], uuid)


	def __generateTraceChatAccount(self, issuer, partyId, partyName, idApp):
		uuid = "kb:" + CaseJson.__createUUID()
		partyId = partyId.replace('"', '')
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:Account", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += CaseJson.C_TAB*3 + '"uco-observable:accountIssuer": "' + issuer + '",\n'		
		# in CASE 0.4 applicationIdentifier --> accountIdentifier
		#line += CaseJson.C_TAB*3 + '"uco-observable:applicationIdentifier": "' + partyId + '",\n' 
			CaseJson.C_TAB*3 + '"uco-observable:accountIdentifier": "' + partyId + '",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:isActive":"true"\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:ApplicationAccount",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:application":\n', \
			CaseJson.C_TAB*4 + '{\n', \
			CaseJson.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			CaseJson.C_TAB*4  + '}\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:DigitalAccount",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:displayName":"' + partyName + '"\n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
		
		TOlist = ''
		for item in idToList:
			if item in self.CHATparticipantsIdList:
				idx = self.CHATparticipantsIdList.index(item)
				TOlist = '{"@id":"' + self.CHATaccountIdList[idx] + '"},'
			else:
				TOlist = '{"@id":"' + self.phoneOwnerUuid + '"},'

		TOlist = TOlist[0:-1] 

		if idFrom in self.CHATparticipantsIdList:
			idx = self.CHATparticipantsIdList.index(idFrom)
			FROMitem = self.CHATaccountIdList[idx]
		else:
			FROMitem = 'ID ' + idFrom + ' NOT_FOUND'
		
		body = body.replace('"', "'")
		body = body.replace('\n', ' ')
		body = body.replace('\t', ' ')
		body = body.replace("\\'", "'")
		body = body.replace("\\", "")
		TOlist = TOlist.replace('\t', ' ')

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Message", \n', \
			CaseJson.C_TAB*2 + '"uco-observable:messageText":"' + body + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:application":\n', \
			CaseJson.C_TAB*3 + '{\n', \
			CaseJson.C_TAB*3 + '"@id":"' + idApplication + '"\n', \
			CaseJson.C_TAB*3 + '},\n', \
			CaseJson.C_TAB*2 + '"uco-observable:sentTime":\n', \
			CaseJson.C_TAB*3 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			CaseJson.C_TAB*3 + '"@value":"' + timeStamp + '"\n', \
			CaseJson.C_TAB*3 + '},\n', \
			CaseJson.C_TAB*2 + '"uco-observable:from":{\n', \
			CaseJson.C_TAB*3 + '"@id":"' + FROMitem + '"\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '"uco-observable:to":[\n', \
			CaseJson.C_TAB*3 + TOlist + '],\n', \
			CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '",\n', \
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:out property in Observable
#
		#line += CaseJson.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '",\n'
			CaseJson.C_TAB*2 + '"uco-observable:messageType":"' + direction + '"\n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line)
		
		#each Message, within a specific Chat can have more than one attachment,
		# both the Filenames and the Urls of the Attachment are separated by
		# a triple hash tag # 
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i in range(len(listFileNames)):
			if (listFileNames[i].strip() == '') and \
			 	(listFileUrls[i].strip() == ''):
				pass
			else:
				# listFileUrls[i] will be stored in the property
				# path of the FILE trace
				fileUuid = self.__generateTraceFile(listFileNames[i], 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, listFileUrls[i],
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)
				
				self.__generateTraceRelation(fileUuid, uuid, 'attachment-of', 
				CaseJson.C_NP, CaseJson.C_NP)
		return uuid


	def __generateTraceDevice(self, deviceMAC, deviceSN, deviceModel,
		deviceOS, deviceOSVersion, deviceManufacturer, deviceWiFi, deviceICCID,
		deviceIMSI, deviceIMEI, deviceBluetoothAddress):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:Device",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:model":"' + deviceModel + '",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:serialNumber":"' + deviceSN + '"\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"uco-observable:MobileDevice",\n', \
			CaseJson.C_TAB*3 + '"uco-observable:IMEI":"' + deviceIMEI + '"\n', \
		
#	if properties are not provided, the related line is not written
#
		#line += CaseJson.C_TAB*2 + '"uco-observable:bluetoothDeviceName":"NOT_PROVIDED",\n'
		#line += CaseJson.C_TAB*2 + '"uco-observable:mockLocationsAllowed":"NOT_PROVIDED",\n'		
		#	line += CaseJson.C_TAB*2 + '"uco-observable:phoneActivationTime":\n'
		#line += CaseJson.C_TAB*3 + '{\n'
		#line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		#line += CaseJson.C_TAB*3 + '"@value":"NOT_PROVIDED"\n'
		#line += CaseJson.C_TAB*3 + '},\n'
		
		#line += CaseJson.C_TAB*2 + '"uco-observable:storageCapacityInBytes":{\n'
		#line += CaseJson.C_TAB*3 + '"@type": "xsd:long",\n'
		#line += CaseJson.C_TAB*3 + '"@value": "NOT_PROVIDED"\n'
		#line += CaseJson.C_TAB*2 + '},\n'

		#line += CaseJson.C_TAB*2 + '"uco-observable:clockSetting":"NOT_PROVIDED"\n'
			CaseJson.C_TAB*2 + '},\n' , \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:OperatingSystem",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:name": "' + deviceOS + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:manufacturer":"' + deviceManufacturer + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:version":"' + deviceOSVersion + '"\n', \
			CaseJson.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, nither observable:AndroidDevice nor observable:AppleDevice are
#	classes of the observable.ttl ontology
#
		#line += CaseJson.C_TAB*2 + '{\n'		
		#if deviceOS.lower() == 'android':
		#	line += CaseJson.C_TAB*2 + '"@type":"uco-observable:AndroidDevice",\n'
		#	line += CaseJson.C_TAB*2 + '"uco-observable:androidID": "NOT_PROVIDED",\n'
		#	line += CaseJson.C_TAB*2 + '"uco-observable:androidSerialNumber": "' + deviceSN + '",\n'
		#else:
		#	line += CaseJson.C_TAB*2 + '"@type":"AppleDevice",\n'
		#	line += CaseJson.C_TAB*2 + '"uco-observable:AppleDeviceID": "NOT_PROVIDED",\n'
		#	line += CaseJson.C_TAB*2 + '"uco-observable:AppleDevideSerialNumber": "' + deviceSN + '",\n'

		#line += CaseJson.C_TAB*2 + '"uco-observable:screenUnlockPattern":"NOT_PROVIDED"\n'
		#line += CaseJson.C_TAB*2 + '},\n'
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:BluetoothAddress",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:addressValue":"' + deviceBluetoothAddress + '"\n', \
			CaseJson.C_TAB*2 + '},\n ', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:WifiAddress",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:addressValue":"' + deviceWiFi + '"}\n', \
		
		#line += CaseJson.C_TAB*2 + '{\n'
		#line += CaseJson.C_TAB*2 + '"@type":"uco-observable:MobileAccount",\n '
		#line += CaseJson.C_TAB*2 + '"uco-observable:MSISDN":"NOT_PROVIDED"\n'
		#line += CaseJson.C_TAB*2 + '}\n'
			CaseJson.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line)
		return uuid
	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, 
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):

		if EMAILidentifierFROM.strip() in self.EMAILaddressList:
			idx = self.EMAILaddressList.index(EMAILidentifierFROM.strip())
			idFROM = self.EMAILaccountIdList[idx]
		else:
			self.EMAILaddressList.append(EMAILidentifierFROM.strip())
			uuidEmail = self.__generateTraceEmailAccount(EMAILidentifierFROM.strip())
			self.EMAILaccountIdList.append(uuidEmail)
			idFROM = uuidEmail

		itemsTO = ''
		for i in range(len(EMAILidentifiersTO)):
			if EMAILidentifiersTO[i].strip() == '':
				pass
			else:
				if EMAILidentifiersTO[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersTO[i].strip())
					idTO = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersTO[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersTO[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idTO = '{"@id":"' + uuidEmail + '"}'
				itemsTO += itemsTO + idTO + ','
		
		# get rid of the last comma
		itemsTO = itemsTO[0:-1]

		itemsCC = ''
		for i in range(len(EMAILidentifiersCC)):
			if EMAILidentifiersCC[i].strip() == '':
				pass
			else:
				if EMAILidentifiersCC[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersCC[i].strip())
					idCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersCC[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersCC[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idCC = '{"@id":"' + uuidEmail + '"}'
				itemsCC += itemsCC + idCC + ','

		# get rid of the last comma
		itemsCC = itemsCC[0:-1]

		#	CASE 0.2/UCO 0.4 compliant, the right property is bcc
#		
		
		itemsBCC = ''
		for i in range(len(EMAILidentifiersBCC)):
			if EMAILidentifiersBCC[i].strip() == '':
				pass
			else:
				if EMAILidentifiersBCC[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersBCC[i].strip())
					idBCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersBCC[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersBCC[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idBCC = '{"@id":"' + uuidEmail + '"}'
				itemsBCC += itemsBCC + idBCC + ','

		# get rid of the last comma
		itemsBCC = itemsBCC[0:-1]

		body = EMAILbody.replace('"', "")
		body = body.replace('\n', ' ')		
		#--- backslash and tab chars are not accepted in JSON value
		body = body.replace('\t', ' ')
		body = body.replace('\\', ' _BS_ ')

		subject = EMAILsubject.replace('"', "")
		subject = subject.replace('\n', ' ')
		subject = subject.replace('\\', ' _BS_ ')

		uuid = "kb:" + CaseJson.__createUUID()

		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:EmailMessage",\n', \
#	CASE 0.2/UCO 0.4 compliant, it would be necessary to create a idref to the application
#
		#line += CaseJson.C_TAB*2 + '"uco-observable:application":"' + EMAILsource + '",\n'
			CaseJson.C_TAB*2 + '"uco-observable:sentTime":\n', \
			CaseJson.C_TAB*3 + '{\n', \
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			CaseJson.C_TAB*3 + '"@value":"' + EMAILtimeStamp + '"\n', \
			CaseJson.C_TAB*3 + '},\n', \

#	CASE 0.2/UCO 0.4 compliant, the right property is from
#			
			CaseJson.C_TAB*2 + '"uco-observable:isMimeEncoded":false,\n', \
			CaseJson.C_TAB*2 + '"uco-observable:isMultipart":false,\n', \
			CaseJson.C_TAB*2 + '"uco-observable:from":{\n', \
			CaseJson.C_TAB*3 + '"@id":"' + idFROM + '"\n', \
			CaseJson.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is to
#		
			CaseJson.C_TAB*2 + '"uco-observable:to":[', \
			itemsTO + '],\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is cc
#		
			CaseJson.C_TAB*2 + '"uco-observable:cc":[', \
			itemsCC + '],\n', \
			CaseJson.C_TAB*2 + '"uco-observable:bcc":[', \
			itemsBCC + '],\n', \
			CaseJson.C_TAB*2 + '"uco-observable:body":"' + body + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:subject":"' + subject + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"' + EMAILstatus + '"\n', \
			CaseJson.C_TAB*2 + '} \n', \
			CaseJson.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line);
		self.__generateChainOfEvidence(EMAILid, uuid)

		for i in range(len(EMAILattachmentsFilename)):
			if EMAILattachmentsFilename[i].strip() == '':
				pass
			else:
				fileUuid = self.__generateTraceFile(EMAILattachmentsFilename[i], 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
  				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
  				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)
				self.__generateTraceRelation(fileUuid, uuid, 'attachment-of', 
				CaseJson.C_NP, CaseJson.C_NP)
		return uuid

	def __generateTraceEmailAccount(self, address):
		
		uuidAddress = self.__generateTraceEmailAddress(address)

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n', \

#	CASE 0.2/UCO 0.4 compliant, there is no property accountIssuer
#		
		#line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer": "' + \
		#	CaseJson.C_NP + '",\n'
			CaseJson.C_TAB*2 + '"uco-observable:isActive":"true",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n', \
			CaseJson.C_TAB*2 + '},\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:EmailAccount", \n', \
			CaseJson.C_TAB*2 + '"uco-observable:emailAddress":"' + uuidAddress + '"\n', \
			CaseJson.C_TAB*2 + '}\n', \
			CaseJson.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceEmailAddress(self, address):
		
		address = address.replace('"', "'")

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:EmailAddress", \n', \
			CaseJson.C_TAB*2 + '"uco-observable:value":"' + address +'"\n', \
			CaseJson.C_TAB + '}\n', \
			CaseJson.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEiNode, FILEiNodeTimeM, FILEgid, FILEuid):
		
		head, tail = os.path.split(FILEpath)
		tail = tail.replace("\\", "/")
		tail = tail.replace('"', "'")
		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")
		dotPos = tail.find('.')
		sExt = tail[dotPos:]

		if  FILEsize.strip == '0':
			 sizeFile = CaseJson.C_TAB*2 + '}\n'
		else:
			sizeFile = "".join([CaseJson.C_TAB*2 + '},\n' ,\
				CaseJson.C_TAB*2 + '{\n',\
				CaseJson.C_TAB*2 + '"@type":"uco-observable:ContentData",\n',\
				CaseJson.C_TAB*2 + '"uco-observable:hash":[\n',\
				CaseJson.C_TAB*3 + '{\n',\
				CaseJson.C_TAB*3 + '"@type":"uco-types:Hash",\n',\
				CaseJson.C_TAB*3 + '"uco-types:hashMethod":\n',\
				CaseJson.C_TAB*4 + '{\n',\
				CaseJson.C_TAB*4 + '"@type": "uco-vocabulary:HashNameVocab",\n',\
				CaseJson.C_TAB*4 + '"@value": "' + FILEhashType + '"\n',\
				CaseJson.C_TAB*4 + '},\n',\
				CaseJson.C_TAB*3 + '"uco-types:hashValue":\n',\
				CaseJson.C_TAB*4 + '{\n',\
				CaseJson.C_TAB*4 + '"@type": "xsd:hexBinary",\n',\
				CaseJson.C_TAB*4 + '"@value":"' + FILEHashValue  + '"\n',\
				CaseJson.C_TAB*4 + '}\n',\
				CaseJson.C_TAB*3 + '}\n',\
				CaseJson.C_TAB*2 + '] \n',\
			#line += CaseJson.C_TAB*2 +  '"uco-observable:SizeInBytes":"256"\n'
				CaseJson.C_TAB*2 + '}\n'])

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n', \
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n', \
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:tag":["' + FILETag + '"],\n'	, \
			CaseJson.C_TAB + '"uco-core:facets":[\n', \
			CaseJson.C_TAB*2 + '{\n', \
			CaseJson.C_TAB*2 + '"@type":"uco-observable:File",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:fileName":"' + tail + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:filePath":"' + path + '",\n', \
#	CASE 0.2/UCO 0.4 compliant, no 	uco-observable:fileLocalPath property in observable.ttl
#				
		#localPath = FILElocalPath.replace("\\", "/")
		#line += CaseJson.C_TAB*2 + '"uco-observable:drafting:fileLocalPath":"' + localPath + '",\n' 		
		
			CaseJson.C_TAB*2 + '"uco-observable:extension":"' + sExt + '",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:fileSystemType":"userdata (ExtX)",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:isDirectory":"false",\n', \
			CaseJson.C_TAB*2 + '"uco-observable:sizeInBytes": {\n',\
			CaseJson.C_TAB*2 + '"@type":"xsd:long", \n',\
			CaseJson.C_TAB*2 + '"@value":"' + FILEsize + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:createdTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + FILEtimeC + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:modifiedTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + FILEtimeM + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:accessedTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + FILEtimeA + '"\n',\
			CaseJson.C_TAB*3 + '}\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:ExtInode",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:extInode":"' + FILEiNode + '",\n' ,\
			CaseJson.C_TAB*2 + '"uco-observable:extSGID":"' + FILEgid + '",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:extSUID":"' + FILEuid + '",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:extInodeChangeTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + FILEiNodeTimeM + '"\n',\
			CaseJson.C_TAB*3 + '}\n',\
			sizeFile, \
			CaseJson.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line);
		return uuid


	def __generateTraceIdentity(self, name, familyName, birthDate):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-identity:Identity",\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-identity:SimpleName",\n',\
			CaseJson.C_TAB*2 + '"uco-identity:givenName":"' + name + '",\n',\
			CaseJson.C_TAB*2 + '"uco-identity:familyName":"' + familyName + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-identity:BirthInformation",\n',\
			CaseJson.C_TAB*2 + '"uco-identity:birthDate":{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + birthDate + '"\n',\
			CaseJson.C_TAB*2 + '}\n',\
			CaseJson.C_TAB + '}\n',\
			CaseJson.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneAccount(self, Source, Name, PhoneNum):
		
		if Source == "":
			sourceLine= ''
		else:
			sourceLine += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[ \n',\
			CaseJson.C_TAB*2 + '{ \n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n',\
			sourceLine,\
			CaseJson.C_TAB*2 + '"uco-observable:isActive":"true",\n' ,\
			CaseJson.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n' ,\
			CaseJson.C_TAB*2 + '}, \n',\
			CaseJson.C_TAB*2 + '{ \n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneAccount", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '" \n',\
#	CASE 0.2/UCO 0.4 compliant, no 	uco-observable:name property in observable.ttl
#			
		#line += CaseJson.C_TAB*2 + '"uco-observable:name":"' + Name + '" \n'
			CaseJson.C_TAB*2 + '} \n',\
			CaseJson.C_TAB + '] \n',\
			'}, \n'])
		self.FileOut.write(line);
		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = ''
		for i in range(n - 1):
			lineResult += CaseJson.C_TAB*3 + '{"@id":"' + listResult[i] + '"},';

		if n > 0:
			lineResult += '{"@id":"' + listResult[n - 1]  + '"}\n'
			lineResult += CaseJson.C_TAB*2 + ']\n'
			lineResult += CaseJson.C_TAB*2 + '}';


		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB +  '"@type":"uco-action:Action",\n',\
			CaseJson.C_TAB +  '"uco-action:name":"' + name + '",\n',\
			CaseJson.C_TAB + '"uco-action:description":"' + description + '",\n',\
			CaseJson.C_TAB*2 + '"uco-action:startTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-action:endTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + endTime + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-action:ActionReferences",\n' ,\
			CaseJson.C_TAB*2 + '"uco-action:instrument":{\n',\
			CaseJson.C_TAB*3 + '"@id":"' + idInstrument + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-action:location":{\n',\
			CaseJson.C_TAB*3 + '"@id":"' + location + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-action:performer":{\n',\
			CaseJson.C_TAB*3 + '"@id":"' + idPerformer + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-action:object":[\n',\
			CaseJson.C_TAB*3 + '{"@id":"' + idObject + '"}\n',\
			CaseJson.C_TAB*2 + '],\n',\
			CaseJson.C_TAB*2 + '"uco-action:result":[\n',\
			lineResult,\
			CaseJson.C_TAB + ']\n',\
			'}' + endChar + '\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):

		nTime = 0
		if duration == "":
			pass
		else:
			aTime = duration.split(":")
			if len(aTime) == 3:
				nTime = aTime[0]*3600 + aTime[1]*60 + aTime[2] 
			if len(aTime) == 2:
				nTime = aTime[0]*60 + aTime[1] 
			if len(aTime) == 1:
				nTime = aTime[0] 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[ \n',\
			CaseJson.C_TAB*2 + '{ \n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneCall", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:callType":"' + direction + '",\n ',\
			CaseJson.C_TAB*2 + '"uco-observable:startTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:application":"Native", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:from":{\n',\
			CaseJson.C_TAB*3 + '"@id":"' + idFROM + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:to":{\n',\
			CaseJson.C_TAB*3 + '"@id":"' + idTO + '"\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:duration":{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:long",\n',\
			CaseJson.C_TAB*3 + '"@value":' + duration + '\n',\
			CaseJson.C_TAB*3 + '},\n',\
#	CASE 0.2/UCO 0.4 compliant no uco-observable:outcome property in Observable
#		
		#line += CaseJson.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '", \n'
			CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '" \n',\
			CaseJson.C_TAB*2 + '}\n' ,\
			CaseJson.C_TAB + '] \n',\
			'}, \n'])
		self.FileOut.write(line);
		return uuid
	

	def __generateTracePhoneOwner(self, Source, Name, PhoneNum):
		
		if Source == "":
			lineSource = ''
		else:
			lineSource = CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'
		
		self.phoneOwnerUuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' + self.phoneOwnerUuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[ \n',\
			CaseJson.C_TAB*2 + '{ \n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:isActive":"true",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n' ,\
			CaseJson.C_TAB*2 + '}, \n',\
			CaseJson.C_TAB*2 + '{ \n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneAccount", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '" \n',\
			lineSource,\
#	CASE 0.2/UCO 0.4 compliant	
#	
		#line += CaseJson.C_TAB*2 + '"uco-observable:name":"' + Name + '" \n'
			CaseJson.C_TAB*2 + '} \n',\
			CaseJson.C_TAB + ']\n',\
			'}, \n'])
		self.FileOut.write(line);
		self.phoneNumberList.append(PhoneNum)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		
		#idx = 0
		n = len(idTracesList)
		lineTraces = ''
		
		for idx in range(n - 1):
			lineTraces += CaseJson.C_TAB*2  + '{"@id":"' + idTracesList[idx] + '"},\n'

		if n > 0:
			lineTraces += CaseJson.C_TAB*2  + '{"@id":"' + idTracesList[n - 1] + '"}\n'

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-investigation:ProvenanceRecord", \n',\
			CaseJson.C_TAB*2 + '"uco-investigation:createdTime":\n',\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			CaseJson.C_TAB*3 + '"@value":"' + creationTime + '"\n',\
			CaseJson.C_TAB*3 + '},\n',\
			CaseJson.C_TAB + '"uco-investigation:description":"' + description + '",\n',\
			CaseJson.C_TAB + '"uco-investigation:exhibitNumber":"' + exhibitNumber + '",\n',\
			CaseJson.C_TAB + '"uco-investigation:object":[\n',\
			lineTraces,\
			CaseJson.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid


	def __generateTraceRelation(self, source, target, relation, table, offset):
		
		if not table == '':
			lineTable = "".join([CaseJson.C_TAB + '"uco-core:isDirectional":"True",\n',\
				CaseJson.C_TAB + '"uco-core:facets": [\n',\
				CaseJson.C_TAB*2 + '{\n ',\
				CaseJson.C_TAB*3 + '"@type":"uco-observable:DataRange",\n',\
				CaseJson.C_TAB*3 + '"uco-observable:rangeOffset":"' + offset + '",\n',\
				CaseJson.C_TAB*3 + '"uco-observable:rangeSize":"" \n',\
				#CaseJson.C_TAB*3 + '"uco-observable:rangeOffsetType":"',\
				#table + '"\n',\
				CaseJson.C_TAB*2 + '}\n ',\
				CaseJson.C_TAB + ']'])
		else:
			lineTable = CaseJson.C_TAB + '"uco-core:isDirectional":"True"\n'

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-core:Relationship",\n',\
			CaseJson.C_TAB + '"uco-core:source":{\n',\
			CaseJson.C_TAB*2 + '"@id":"' + source + '"\n',\
			CaseJson.C_TAB + '},\n',\
			CaseJson.C_TAB + '"uco-core:target":{\n' ,\
			CaseJson.C_TAB*2 + '"@id":"' + target + '"\n',\
			CaseJson.C_TAB + '},\n',\
			CaseJson.C_TAB + '"uco-core:kindOfRelationship":{' + '\n',\
			CaseJson.C_TAB*2 + '"@type": "uco-vocabulary:CyberItemRelationshipVocab",\n',\
			CaseJson.C_TAB*2 + '"@value":"'		+ relation + '"\n',\
			CaseJson.C_TAB + '},\n',\
			lineTable,\
			'},\n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceRole(self, role):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-role:Role",\n',\
			CaseJson.C_TAB + '"uco-role:name":"' + role + '"\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceSms(self, SMSid, SMSstatus, SMStimeStamp, 
							SMSpartyRoles, SMSpartyIdentifiers, 
							SMSpartyNames, SMSbody, SMSsource):
		for i in range(len(SMSid)):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			for j in range(len(SMSpartyIdentifiers[i])):
				if SMSpartyIdentifiers[i][j].strip() == '':
					pass
				else:
					if SMSpartyIdentifiers[i][j] in self.phoneNumberList:
						idx = self.phoneNumberList.index(SMSpartyIdentifiers[i][j])
						userId = self.phoneNumberList[idx]
						phonePartyUuid = self.phoneUuidList[idx]
					else:
# see previous comment of the use of the mobileOperator variable
						mobileOperator = ""
						phonePartyUuid = self.__generateTracePhoneAccount(mobileOperator, 
							SMSpartyNames[i][j], SMSpartyIdentifiers[i][j])	
				
					phoneUuidTo = ''
	        		# Party with Role=TO can be more than one
					if SMSpartyRoles[i][j] == 'To':
						phoneUuidFrom = self.phoneOwnerUuid
						phoneUuidTo += '{"@id":"' + phonePartyUuid + '"}' + ','
					else:
						phoneUuidFrom = phonePartyUuid
						phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'
			if phoneUuidTo == self.phoneOwnerUuid:
				phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'	
			else:
			# get rid of the last comma if the field is not empty
				if phoneUuidTo == '':
					pass
				else:
					if phoneUuidTo[-1] == ',':
						phoneUuidTo = phoneUuidTo[0:-1]

			body = SMSbody[i].replace('\n', ' ')
			body = body.replace('"', "'")
			body = body.replace('\t', ' ')
			body = body.replace("\\'", "'")
			body = body.replace("\\", "")

			uuid = "kb:" + CaseJson.__createUUID()
			line = "".join(['{ \n', \
				CaseJson.C_TAB + '"@id":"' + uuid + '", \n',\
				CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
				CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
				CaseJson.C_TAB + '"uco-core:facets":[ \n',\
				CaseJson.C_TAB*2 + '{ \n',\
				CaseJson.C_TAB*2 + '"@type":"uco-observable:Message", \n' ,\
#	CASE 0.2/UCO 0.4 compliant,  uco-observable:application is always the native app 
#	installed on the mobile phone
# 
			#line += CaseJson.C_TAB*2 + '"uco-observable:application":"' + SMSsource[i] + '", \n' 
			
#	CASE 0.2/UCO 0.4 compliant,  uco-observable:SMSMessage is a class, not clear its possible
# values
#
			#line += CaseJson.C_TAB*2 + '"uco-observable:SMSmessage":"true", \n'
				CaseJson.C_TAB*2 + '"uco-observable:messageText":"' + body + '", \n',\
				CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"' + SMSstatus[i] + '", \n',\
				CaseJson.C_TAB*2 + '"uco-observable:from":{\n',\
				CaseJson.C_TAB*3 + '"@id":"' + phoneUuidFrom + '"\n',\
				CaseJson.C_TAB*2 + '},\n',\
				CaseJson.C_TAB*2 + '"uco-observable:to":[' + phoneUuidTo + '], \n',\
				CaseJson.C_TAB*2 + '"uco-observable:sentTime":{\n',\
				CaseJson.C_TAB*3 + '"@type": "xsd:dateTime", \n' ,\
				CaseJson.C_TAB*3 + ' "@value": "' + SMStimeStamp[i] + '"\n',\
				CaseJson.C_TAB*3 + '} \n'	,\
				CaseJson.C_TAB*2 + '} \n',\
				CaseJson.C_TAB + '] \n',\
				'}, \n'])
			self.FileOut.write(line)
			self.__generateChainOfEvidence(SMSid[i], uuid)

	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		
		nChatThread = len(chatThread)
		lineThread  = ''
		for i in range(nChatThread - 1):
			lineThread += CaseJson.C_TAB*3 + '{\n'
			lineThread += CaseJson.C_TAB*4 + '"olo:index":"' + str(i + 1) + '",\n'
			lineThread += CaseJson.C_TAB*4 + '"olo:item": {\n'
			lineThread += CaseJson.C_TAB*5 + '"@id":"' + chatThread[i] + '"\n'
			lineThread += CaseJson.C_TAB*4 + '}\n'
			lineThread += CaseJson.C_TAB*3 + '},\n'

		nChatAccounts = len(chatIdAccountList)
		lineChatAccounts = ''		
		for i in range(nChatAccounts - 1):
			lineChatAccounts += CaseJson.C_TAB*3 + '{"@id":"' + chatIdAccountList[i] + '"},\n'

		if nChatAccounts > 0:
			lineChatAccounts += CaseJson.C_TAB*3  + '{"@id":"' + chatIdAccountList[nChatAccounts - 1] + '"}]\n' 

		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:MessageThread",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:displayName":"",\n',\
			CaseJson.C_TAB*2 + '"uco-observable:message":{\n',\
			CaseJson.C_TAB*2 + '"olo:length":"' + str(len(chatThread)) + '",\n',\
			CaseJson.C_TAB*2 + '"olo:slot":[\n',\
			lineThread,\
			CaseJson.C_TAB*3 + '{\n',\
			CaseJson.C_TAB*4 + '"olo:index":"' + str(nChatThread) + '",\n',\
			CaseJson.C_TAB*4 + '"olo:item": {\n',\
			CaseJson.C_TAB*5 + '"@id":"' + chatThread[nChatThread - 1] + '"\n',\
			CaseJson.C_TAB*4 + '}\n',\
			CaseJson.C_TAB*3 + '}\n',\
			CaseJson.C_TAB*3 + ']\n',\
			CaseJson.C_TAB*2 + '},\n',\
			CaseJson.C_TAB*2 + '"uco-observable:participants":[\n',\
			lineChatAccounts,\
			CaseJson.C_TAB*2 + '}\n',\
			CaseJson.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		#self.__generateChainOfEvidence(chatTraceId, uuid)
		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-tool:Tool", \n',\
			CaseJson.C_TAB + '"uco-core:name":"' + name + '",\n' ,\
			CaseJson.C_TAB + '"uco-tool:toolType":"' + type + '",\n',\
			CaseJson.C_TAB + '"uco-tool:creator":"' + vendor + '",\n',\
			CaseJson.C_TAB + '"uco-tool:version":"' + version + '"\n'])

		if len(confList) > 0:  
			line += line + ',\n'
			line += CaseJson.C_TAB + '"uco-core:facets":[\n'
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-tool:ConfigurationSettingType",\n'
			line += CaseJson.C_TAB*2 + '"configurationSetting":[\n'
			n = len(confList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += CaseJson.C_TAB*3 + '{\n'
				line += CaseJson.C_TAB*3 + '"@type":"uco-tool:ConfigurationSettingType",\n'
				line += CaseJson.C_TAB*3 + '"uco-tool:itemName":"' + listItems[0] + '",\n'
				line += CaseJson.C_TAB*3 + '"uco-tool:itemValue":"' + listItems[1] + '"\n'
				line += CaseJson.C_TAB*3 + '},\n' 
    
			listItems.clear()
			listItems += confList[n].split('@')
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:ConfigurationSetting",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:itemName":"' + listItems[0] + '",\n' 
			line += CaseJson.C_TAB*2 + '"uco-observable:itemValue":"' + listItems[1] + '"\n'
			line += CaseJson.C_TAB*2 + '}\n'
			line += CaseJson.C_TAB*2 + ']\n'
			line += CaseJson.C_TAB + '}\n'
			line += CaseJson.C_TAB + ']\n'
			line += '}\n';
		else:
			line += '},\n';

		self.FileOut.write(line);
		return uuid

	def __generateTraceURL (self, URL_Value):
		uuid = "kb:" + CaseJson.__createUUID()
		line = "".join(['{ \n', \
			CaseJson.C_TAB + '"@id":"' +  uuid + '", \n',\
			CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n',\
			CaseJson.C_TAB + '"uco-observable:hasChanged":true,\n',\
			CaseJson.C_TAB + '"uco-core:facets":[\n',\
			CaseJson.C_TAB*2 + '{\n',\
			CaseJson.C_TAB*2 + '"@type":"uco-observable:URL", \n',\
			CaseJson.C_TAB*2 + '"uco-observable:fullValue":"' + URL_Value + '"\n',\
			CaseJson.C_TAB*2 + '}\n',\
			CaseJson.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited):
		for i in range(len(WEB_PAGEid)):
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:URLHistory property in Observable
#
			#uuid = "kb:" + CaseJson.__createUUID()
			#line = '\n{ \n'
			#line += CaseJson.C_TAB + '"@id":"' +  uuid + '", \n'
			#line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
			#line += CaseJson.C_TAB + '"uco-core:facets":[\n'
			#line += CaseJson.C_TAB*2 + '{\n'
			#line += CaseJson.C_TAB*2 + '"@type":"uco-observable:URLHistory", \n'
			#line += CaseJson.C_TAB*2 + '"uco-observable:browserInformation":"' 
			#line += WEB_PAGEsource[i] + '", \n'
			#line += CaseJson.C_TAB*2 + '"uco-observable:urlHistoryEntry": [\n'
			#line += CaseJson.C_TAB*2 + '{\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:firstVisit":\n'
			#line += CaseJson.C_TAB*4 + '{\n'
			#line += CaseJson.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			#line += CaseJson.C_TAB*4 + '"@value":"NOT_PROVIDED"\n'
			#line += CaseJson.C_TAB*4 + '},\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:lastVisit":\n'
			#line += CaseJson.C_TAB*4 + '{\n'
			#line += CaseJson.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			#line += CaseJson.C_TAB*4 + '"@value":"' + WEB_PAGElastVisited[i] + '"\n'
			#line += CaseJson.C_TAB*4 + '},\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:expiration":"NOT_PROVIDED",\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:userProfile":"NOT_PROVIDED",\n'
			uuidUrl = self.__generateTraceURL(WEB_PAGEurl[i])
			#line += CaseJson.C_TAB*3 + '"uco-observable:url":{\n' 
			#line += CaseJson.C_TAB*4 + '"@id":"' + uuidUrl + '"\n'
			#line += CaseJson.C_TAB*3 + '},\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:referrerUrl":"NOT_PROVIDED",\n'			
			#line += CaseJson.C_TAB*3 + '"uco-observable:pageTitle":"' 
			#title = WEB_PAGEtitle[i].replace('"', '')
			#line += title + '",\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:visitCount":"' 
			#line += WEB_PAGEvisitCount[i] + '",\n' 
			#line += CaseJson.C_TAB*3 + '"uco-observable:manuallyEnteredCount":0,\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:keywordSearchTerm":"NULL",\n'
			
			#line += CaseJson.C_TAB*3 + '"uco-observable:typedCount":"0",\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:duration":{\n'
			#line += CaseJson.C_TAB*3 + '"@type":"xsd:long",\n'
			#line += CaseJson.C_TAB*4 + '"@value":0\n'
			#line += CaseJson.C_TAB*4 + '},\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:transitiontype":"NOT_PROVIDED",\n'
			#line += CaseJson.C_TAB*3 + '"uco-observable:searchterm":"NOT_PROVIDED",\n'
			
			#line += CaseJson.C_TAB*3 + '"uco-observable:allocationStatus":"' 
			#line += WEB_PAGEstatus[i] + '" \n' 
			#line += CaseJson.C_TAB*3 + '}\n'
			#line += CaseJson.C_TAB*2 + ']\n'  						
			#line += CaseJson.C_TAB + '}\n'  					
			#line += CaseJson.C_TAB + ']\n'  						
			#line += '},\n'  						
			#self.FileOut.write(line);
			
			#print("WEB_PAGEid" + WEB_PAGEid[i] + "\n")
			endChar = ','
			#last web page item, endChar is not "," (default) but " "
			if i == len(WEB_PAGEid) - 1:
				endChar	= ' '

			#self.__generateChainOfEvidence(WEB_PAGEid[i], uuid, endChar)

	#not used anymore, every time the field Source is extracted
	# an uco-observable:Application item is created
	def storeUserAccount(self, U_ACCOUNTsource, U_ACCOUNTname,
			U_ACCOUNTusername):
		for i in range(len(U_ACCOUNTsource)):
			idAppName = self.__generateTraceAppName(U_ACCOUNTsource[i])
			self.appNameList.append(U_ACCOUNTsource[i])
			#self.appAccountNameList.append(U_ACCOUNTname[i])
			#self.appAccountUsernameList.append(U_ACCOUNTusername[i])
			self.appIDList.append(idAppName)


	def writeCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
				CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
				CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
				CALLidentifiersFROM):
		self.__generateTraceCall(CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM)

	def writeExtraInfo(self, EXTRA_INFOdictPath, EXTRA_INFOdictSize, EXTRA_INFOdictTableName, 
				EXTRA_INFOdictOffset, EXTRA_INFOdictNodeInfoId):
		self.EXTRA_INFOdictPath = EXTRA_INFOdictPath
		self.EXTRA_INFOdictSize = EXTRA_INFOdictSize
		self.EXTRA_INFOdictTableName = EXTRA_INFOdictTableName
		self.EXTRA_INFOdictOffset = EXTRA_INFOdictOffset
		self.EXTRA_INFOdictNodeInfoId = EXTRA_INFOdictNodeInfoId		

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i in range(len(CONTACTname)):
			for j in range(len(CONTACTphoneNums[i])):
				if CONTACTphoneNums[i][j] in self.phoneNumberList:					
					pass
				else:
					self.phoneNumberList.append(CONTACTphoneNums[i][j])
					self.phoneNameList.append(CONTACTname[i])
# see previous comment of the use of the mobileOperator variable
					mobileOperator = ""
					uuid = self.__generateTracePhoneAccount(mobileOperator, CONTACTname[i], CONTACTphoneNums[i][j])
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		self.__generateHeader()

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber):
		self.phoneOwnerNumber = phoneOwnerNumber
#	see previous comment of the use of the mobileOperator variable
#	the mobileOwnerName is not available in the XML report		
		mobileOperator = ""
		mobileOwnerName = ""
		self.__generateTracePhoneOwner(mobileOperator, mobileOwnerName, phoneOwnerNumber)

	def writeFiles(self, FILEid, FILEpath, FILEsize, FILEmd5, FILETag, 
					FILEtimeCreate, FILEtimeModify, FILEtimeAccess, FILElocalPath, 
                    FILEiNodeNumber, FILEiNodeTimeM, FILEownerGID, FILEownerUID):
			self.FILEid = FILEid
			for i in range(len(FILEid)):			
				uuid = self.__generateTraceFile(FILEpath[i], FILEsize[i], 
					'MD5', FILEmd5[i],	FILETag[i], FILEtimeCreate[i], FILEtimeModify[i], 
					FILEtimeAccess[i], FILElocalPath[i], FILEiNodeNumber[i], FILEiNodeTimeM[i],
					FILEownerGID[i], FILEownerUID[i])

				self.FILEuuid[FILEid[i]] = uuid

	def writeChat(self, CHATid, CHATstatus, CHATsource, CHATpartyIdentifiers, CHATpartyNames, 
                CHATmsgIdentifiersFrom, CHATmsgNamesFrom, CHATmsgIdentifiersTo, 
                CHATmsgNamesTo, CHATmsgBodies, CHATmsgStatuses, CHATmsgOutcomes,
                CHATmsgTimeStamps, CHATmsgAttachmentFilenames, CHATmsgAttachmentUrls):		
		for i in range(len(CHATid)):
			if CHATsource[i].strip().lower() in self.appNameList: 
				idx = self.appNameList.index(CHATsource[i].strip().lower())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(CHATsource[i].strip())
				self.appNameList.append(CHATsource[i].strip())
				self.appIDList.append(idAppIdentity)
			
			CHATidAccountList = []
			for j in range(len(CHATpartyIdentifiers[i])):				
				if CHATpartyIdentifiers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CHATpartyIdentifiers[i][j].strip())
					CHATidAccountList.append(self.CHATaccountIdList[idx])
				else:
					self.CHATparticipantsNameList.append(CHATpartyNames[i][j].strip())
					idChatAccount = self.__generateTraceChatAccount(CHATsource[i].strip(),
						CHATpartyIdentifiers[i][j].strip(), CHATpartyNames[i][j].strip(),
						idAppIdentity)
					self.CHATparticipantsIdList.append(CHATpartyIdentifiers[i][j].strip())
					self.CHATaccountIdList.append(idChatAccount)
					CHATidAccountList.append(idChatAccount)

			appSource = CHATsource[i].strip().lower()
			# if the Source is whatsapp, then the owner's whatsapp
			# account must be part of the participants of the Chat
			if appSource == 'whatsapp':
				if 'whatsapp' in self.appNameList:
					idx = self.appNameList.index('whatsapp')
				else:
					idApp = self.__generateTraceAppName('whatsapp')
					#idIdentity = self.__generateTraceAppIdentity('WhatsApp')
					self.appNameList.append('whatsapp')
					#self.appAccountUsername.append(idIdentity)
					self.appIDList.append(idApp)
					idx = self.appNameList.index('whatsapp')

				#idAppWhatsApp = self.appAccountUsername[idx]
				idAppWhatsApp = self.appIDList[idx]
				idPhoneOwner = self.phoneOwnerNumber + '@s.whatsapp.net'			
				if idPhoneOwner in self.CHATparticipantsIdList:
					pass
				else:
					self.CHATparticipantsNameList.append('PHONE_OWNER_NAME')
					idChatAccount = self.__generateTraceChatAccount('WhatsApp',
					idPhoneOwner, 'PHONE_OWNER_NAME', idAppWhatsApp)
					self.CHATparticipantsIdList.append(idPhoneOwner)
					self.CHATaccountIdList.append(idChatAccount)

				# the owner's phone num must be always part of the 
				# participants Chat account
				idx = self.CHATparticipantsIdList.index(idPhoneOwner)
				chatAccountPhoneOwner = self.CHATaccountIdList[idx]
				if chatAccountPhoneOwner in CHATidAccountList:
					pass
				else:
					CHATidAccountList.append(chatAccountPhoneOwner)
			
			CHATthread = []
# CHATmsgBodies[i] is the list of the messages of the same thread, the j index
# iterates over all these messages
			for j in range(len(CHATmsgBodies[i])):				
# IdentifiersTo may contain more than one ID, separated by ###. This occurs
# when a message is sent to a group and more than one recipient is involved
				CHATmsgTo = CHATmsgIdentifiersTo[i][j].split('###')	
# if IdentifiersTo is empty, there is only a recipient: the phone owner number								
				CHATmsgFrom = CHATmsgIdentifiersFrom[i][j].strip() 

# if Identifiers TO is empty, the array CHATpartyIdentifiers must
# be iterated to find the right Party
				
				if CHATmsgTo[0].strip() == '':
					for k in range(len(CHATpartyIdentifiers[i])):
						if CHATpartyIdentifiers[i][k] == CHATmsgFrom:
							pass
						else:
							CHATmsgTo[0] = CHATpartyIdentifiers[i][k]
							break
					direction = 'Incoming'
				else:			
					direction = 'Outgoing'
				
# if Identifiers FROM is empty, the array CHATpartyIdentifiers must
# be iterated to find the right Party
				
				if CHATmsgFrom == '':
					for k in range(len(CHATpartyIdentifiers[i])):
						if CHATpartyIdentifiers[i][k] in CHATmsgTo:
							pass
						else:
							CHATmsgFrom = CHATpartyIdentifiers[i][k]
							break
				
				chatUuid = self.__generateTraceChat(CHATmsgBodies[i][j], idAppIdentity, 
					CHATmsgTimeStamps[i][j], CHATmsgFrom, 
					CHATmsgTo, CHATmsgStatuses[i][j], CHATmsgOutcomes[i][j],
					direction, CHATmsgAttachmentFilenames[i][j], 
					CHATmsgAttachmentUrls[i][j])
				CHATthread.append(chatUuid)

			# if there are not messages for this Chat or no ChatAccount has been
			# generated, the ThreadMessage is not generated. Moreover the Chain of
			# evidence is built upon the ThreadUuid
			if (len(CHATthread) == 0) or (len(CHATidAccountList) == 0):
				pass
			else:
				uuidThread = self.__generateThreadMessages(CHATid[i], CHATthread, 
								CHATidAccountList)
				self.__generateChainOfEvidence(CHATid[i], uuidThread)

	def writeEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
                EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename):
		for i in range(len(EMAILid)):
			self.__generateTraceEmail(EMAILid[i], EMAILstatus[i], EMAILsource[i],
				EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited):
		self.__generateTraceWebPages(WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited)

	def writeSms(self, SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles,
					SMSpartyIdentifiers, SMSpartyNames, SMSbody, SMSsource):
		self.__generateTraceSms(SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles, 
					SMSpartyIdentifiers, SMSpartyNames, SMSbody, SMSsource)

	def writeContextUfed(self, ufedVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
		deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextUfed(ufedVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


