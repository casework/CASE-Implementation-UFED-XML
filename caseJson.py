#---	class CaseJson.py

import uuid
import os
import re

class CaseJson:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	C_TAB = '\t'
	C_NP = '_NOT_PROVIDED_'

	def __init__(self, fileOut, appName, appUserName, appUserAccount):
	# to be defined
		self.FileOut = fileOut
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []

		self.EMAILaccountIdList = []
		self.EMAILaddressList = []
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.U_ACCOUNTapp = appName
		self.U_ACCOUNTappUserName = appUserName
		self.U_ACCOUNTappUserAccount = appUserAccount

		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def ___generateContextUfed(self, ufedVersion, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('UFED_PA', 'Acquisition', 
			'Cellebrite', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '');

		# generate Trace/Device for the mobile phone
		idDevice = self.__generateTraceDevice(deviceMacAddress, deviceId, devicePhoneModel,
			deviceOsType, deviceOsVersion, devicePhoneVendor, 'NOT_PROVIDED',
			deviceIccid, deviceImsi, deviceImei, deviceBluetoothAddress)
		
		# generate Trace/Provenance_Record for the mobile device
		idDeviceList = []
		idDeviceList.append(idDevice)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			'NOT_PROVIDED', deviceAcquisitionStartTime) 
		
		# generate Trace/File for each file extracted by the Acuisition action
		# idFileList contains the uuid of these files and it is used for
		# creating the Provenance_Record of the Result/Output of the Acquisition 
		# action
		idFilesAcquisition = []
		for i in range(len(imagePath)):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(imagePath[i], 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], CaseJson.C_NP, 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)  
				 
			else:
				idFileAcquisition = self.__generateTraceFile(imagePath[i], 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], CaseJson.C_NP, 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP) 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
        	'Acquisition files', 'NOT_PROVIDED', deviceAcquisitionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)
        
		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceAcquisitionStartTime, 
			deviceAcquisitionEndTime, idTool, 'NOT_PROVIDED', 
			idIdentity, idDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'NOT_PROVIDED', deviceExtractionStartTime);
        
		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceExtractionStartTime,
			'NOT_PROVIDED', idTool, 'NOT_PROVIDED', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, IdTrace, uuidTrace, endChar=','):
	    # search traceId in EXTRA_INFOdictNodeInfo a dictionary whose keys are the id
	    # that represents the link between a Trace and its file(s)
		table = self.EXTRA_INFOdictTableName.get(IdTrace, '_?TABLE')
		offset = self.EXTRA_INFOdictOffset.get(IdTrace, '_?OFFSET')
		# this is the case where the infoNode sub element of extraInfo contains the id 
	    # reference to the file. More then one infoNode can exist, the value of the key 
	    # contains the id file separated by @@
		if self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '').strip() == '':
			path = self.EXTRA_INFOdictPath.get(IdTrace, '_?PATH')
			size = self.EXTRA_INFOdictSize.get(IdTrace, '_?SIZE')
			uuidFile = self.__generateTraceFile(path, size, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, 
					CaseJson.C_NP, CaseJson.C_NP)

			self.FILEuuid[IdTrace] = uuidFile
			self.__generateTraceRelation(uuidTrace, uuidFile, 'contained_within', 
				table, offset);
		else:
			nodeInfoIdList = self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '@@@').split('@@@')
			for node in nodeInfoIdList:
				if node.strip() != '':
					if node in self.FILEid: 
						#idFile = self.FILEid.index(node)
						#uuid = FILEuuid.get(idFile, '_?UUID')
						uuidFile = self.FILEuuid.get(node, '_?UUID')
						self.__generateTraceRelation(uuidTrace, uuidFile, 'contained_within', 
							table, offset);
					else:
						print ('nodeInfo ' + node + ' not found')
		


	def __generateHeader(self):
		uuid = CaseJson.__createUUID()
		line = '{ \n' + CaseJson.C_TAB + '"@context": { \n'
		line += CaseJson.C_TAB*2 + '"@vocab": "http://caseontology.org/core#", \n'
		line += CaseJson.C_TAB*2 + '"case-investigation": "https://caseontology.org/ontology/case/investigation#", \n'		
		line += CaseJson.C_TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n'
		line += CaseJson.C_TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n'
		line += CaseJson.C_TAB*2 + '"uco-action": "https://unifiedcyberontology.org/ontology/uco/action#", \n'
		line += CaseJson.C_TAB*2 + '"uco-core": "https://unifiedcyberontology.org/ontology/uco/core#", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable": "https://unifiedcyberontology.org/ontology/uco/observable#", \n'
		line += CaseJson.C_TAB*2 + '"uco-tool": "https://unifiedcyberontology.org/ontology/uco/tool#", \n'
		line += CaseJson.C_TAB*2 + '"uco-types": "https://unifiedcyberontology.org/ontology/uco/types#", \n'
		line += CaseJson.C_TAB*2 + '"uco-vocabulary": "https://unifiedcyberontology.org/ontology/uco/vocabulary#", \n'
		line += CaseJson.C_TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n'				
		line += CaseJson.C_TAB*2 + '},\n'
		line += '"@id": ":bundle-' + uuid + '", \n'
		line += '"@type": "uco-core:Bundle",\n'
		line += '"uco-core:description": "Extraction from XML report generated by UFED PA",\n'
		line += '"uco-core:object": [\n'
		self.FileOut.write(line)

	def __generateLastLine(self):
		line = CaseJson.C_TAB + '] \n }'
		self.FileOut.write(line)

	def __generateTraceAppAccount(self, source, name, identifier, idApp, idIdentity):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + idIdentity + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accountIdentifier":"' + identifier + '", \n' 
		line += CaseJson.C_TAB*2 + '"uco-observable:isActive":"true" \n'
		line += CaseJson.C_TAB*2 + '}, \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:ApplicationAccount", \n' 
		line += CaseJson.C_TAB*3 + '"uco-observable:application":{\n'
		line += CaseJson.C_TAB*4 + '"@id": "' + idApp + '"\n'
		line += CaseJson.C_TAB*3  + '}\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:DigitalAccount", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:displayName":"' + name + '"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n'
		line += '}, \n';
		self.FileOut.write(line);
		return uuid
	
	def __generateTraceAppName(self, appName):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Application", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:appName":"' + appName + '" \n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n';
		line += '},\n';
		self.FileOut.write(line);
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:Identity", \n' 
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n' 
		line += CaseJson.C_TAB*2 + '{ \n' 
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Organization", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:orgName":"' + appName + '" \n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n';
		line += '},\n';
		self.FileOut.write(line);
		return uuid


	def __generateTraceCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM):
		for i in range(len(CALLid)):
			# Only traditional, normal phone call are processed: UFED possible values are those
			# those indicated below
			if (CALLsource[i].strip() == '' or 
				CALLsource[i].strip().lower() == 'call' or
				CALLsource[i].strip().lower() == 'native call log'): 
				if CALLdirection[i].lower() == 'incoming':
					if (len(CALLnamesFROM[i]) > 0): 
						nameParty = CALLnamesFROM[i][0]
					else:
						nameParty = 'NOT_PROVIDED'

					if (len(CALLidentifiersFROM[i]) > 0): 
						idParty = CALLidentifiersFROM[i][0]
					else:
						idParty = 'NOT_PROVIDED'											
				else:
					if (len(CALLnamesTO[i]) > 0):
						nameParty = CALLnamesTO[i][0]
					else:
						nameParty = 'NOT_PROVIDED'	

					if (len(CALLidentifiersTO[i]) > 0):
						idParty = CALLidentifiersTO[i][0]					
					else:
						idParty = 'NOT_PROVIDED'	

				# if the identifier of the Call is empty, no CASE object is generated.
				# Some Calls do not have any info on identifier with role TO/FROM
				if idParty.strip() == '':
					continue
				
				if idParty in self.phoneNumberList:
					idx = self.phoneNumberList.index(idParty)
					#userId = self.phoneNumberList[idx]
					uuid = self.phoneUuidList[idx]
				else:						
					uuid = self.__generateTracePhoneAccount('_MOBILE_NETWORK_OPERATOR', 
						nameParty, idParty)
				
				if CALLdirection[i].lower() == 'incoming':
					uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
						CALLtimeStamp[i], self.phoneOwnerUuid, uuid, CALLduration[i],
	                           CALLstatus[i], CALLoutcome[i])
				else:
					uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
						CALLtimeStamp[i], uuid, self.phoneOwnerUuid, CALLduration[i],
	                           CALLstatus[i], CALLoutcome[i])
				self.__generateChainOfEvidence(CALLid[i], uuid)


	def __generateTraceChatAccount(self, issuer, partyId, partyName, idApp):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"uco-observable:Account", \n'
		line += CaseJson.C_TAB*3 + '"uco-observable:accountIssuer": "' + issuer + '",\n'
		partyId = partyId.replace('"', '')
		line += CaseJson.C_TAB*3 + '"uco-observable:applicationIdentifier": "' + partyId + '",\n' 
		line += CaseJson.C_TAB*3 + '"uco-observable:isActive":"true"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"uco-observable:ApplicationAccount",\n'
		line += CaseJson.C_TAB*3 + '"uco-observable:application":{\n'
		line += CaseJson.C_TAB*4 + '"@id": "' + idApp + '"\n'
		line += CaseJson.C_TAB*3  + '}\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:DigitalAccount",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:displayName":"' + partyName + '"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + '] \n'
		line += '}, \n'
		self.FileOut.write(line)
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
		
		TOlist = ''
		for item in idToList:
			if item in self.CHATparticipantsIdList:
				idx = self.CHATparticipantsIdList.index(item)
				TOlist = '{"@id":":' + self.CHATaccountIdList[idx] + '"},'
			else:
				TOlist = '{"@id":":' + self.phoneOwnerUuid + '"},'

		TOlist = TOlist[0:-1] 

		if idFrom in self.CHATparticipantsIdList:
			idx = self.CHATparticipantsIdList.index(idFrom)
			FROMitem = self.CHATaccountIdList[idx]
		else:
			FROMitem = 'ID ' + idFrom + ' NOT_FOUND'
		
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Message", \n'
		body = body.replace('"', "'")
		body = body.replace('\n', ' ')
		body = body.replace('\t', ' ')
		body = body.replace("\\'", "'")
		body = body.replace("\\", "")
		line += CaseJson.C_TAB*2 + '"uco-observable:messageText":"' + body + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:application":"' + idApplication + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:sentTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + timeStamp + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:from":{\n'
		line += CaseJson.C_TAB*3 + '"@id":":' + FROMitem + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'  
		TOlist = TOlist.replace('\t', ' ')
		line += CaseJson.C_TAB*2 + '"uco-observable:to":[\n'
		line += CaseJson.C_TAB*3 + TOlist + '],\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:__status":"' + status + '",\n'		
		line += CaseJson.C_TAB*2 + '"uco-observable:__outcome":"' + outcome + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:messageType":"' + direction + '"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n';
		line += '},\n';
		self.FileOut.write(line)
		
		#each Message, within a specific Chat can have more than one attachment,
		# both the Filenames and the Urls of the Attachment are separated by
		# a triple hash tag # 
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i in range(len(listFileNames)):
			if (listFileNames[i].strip() == '') and \
			 	(listFileUrls[i].strip() == ''):
				pass
			else:
				# listFileUrls[i] will be stored in the property
				# path of the FILE trace
				fileUuid = self.__generateTraceFile(listFileNames[i], 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, listFileUrls[i],
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)
				
				self.__generateTraceRelation(fileUuid, uuid, 'attachment-of', 
				'NOT_PROVIDED', 'NOT_PROVIDED')
		return uuid


	def __generateTraceDevice(self, deviceMAC, deviceSN, deviceModel,
		deviceOS, deviceOSVersion, deviceManufacturer, deviceWiFi, deviceICCID,
		deviceIMSI, deviceIMEI, deviceBluetoothAddress):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Device",\n'		
		line += CaseJson.C_TAB*2 + '"uco-observable:model":"' + deviceModel + '",\n' 
		line += CaseJson.C_TAB*2 + '"uco-observable:serialNumber":"' + deviceSN + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:MobileDevice",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:IMEI":"' + deviceIMEI + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:bluetoothDeviceName":"NOT_PROVIDED",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:mockLocationsAllowed":"NOT_PROVIDED",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:deviceActivationTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"__NOT_PROVIDED"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		
		line += CaseJson.C_TAB*2 + '"uco-observable:storageCapacityInBytes":{\n'
		line += CaseJson.C_TAB*3 + '"@type": "xsd:long",\n'
		line += CaseJson.C_TAB*3 + '"@value": "NOT_PROVIDED"\n'
		line += CaseJson.C_TAB*2 + '},\n'

		line += CaseJson.C_TAB*2 + '"uco-observable:clockSetting":"NOT_PROVIDED"},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:OperatingSystem",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:name": "' + deviceOS + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:manufacturer":"' + deviceManufacturer + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:version":"' + deviceOSVersion + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		if deviceOS.lower() == 'android':
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:AndroidDevice",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:androidID": "NOT_PROVIDED",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:androidSerialNumber": "' + deviceSN + '",\n'
		else:
			line += CaseJson.C_TAB*2 + '"@type":"AppleDevice",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:AppleDeviceID": "NOT_PROVIDED",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:AppleDevideSerialNumber": "' + deviceSN + '",\n'

		line += CaseJson.C_TAB*2 + '"uco-observable:screenUnlockPattern":"NOT_PROVIDED"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:BluetoothAddress",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:address":"' + deviceBluetoothAddress + '"\n' 
		line += CaseJson.C_TAB*2 + '},\n '
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:WiFiAddress",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:address":"' + deviceWiFi + '"},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:MobileAccount",\n '
		line += CaseJson.C_TAB*2 + '"uco-observable:MSISDN":"NOT_PROVIDED"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n';
		line += '},\n';
		self.FileOut.write(line)
		return uuid
	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, 
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:EmailMessage",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:application":"' + EMAILsource + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:sentTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + EMAILtimeStamp + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'

		if EMAILidentifierFROM.strip() in self.EMAILaddressList:
			idx = self.EMAILaddressList.index(EMAILidentifierFROM.strip())
			idFROM = self.EMAILaccountIdList[idx]
		else:
			self.EMAILaddressList.append(EMAILidentifierFROM.strip())
			uuidEmail = self.__generateTraceEmailAccount(EMAILidentifierFROM.strip())
			self.EMAILaccountIdList.append(uuidEmail)
			idFROM = uuidEmail
	
		line += CaseJson.C_TAB*2 + '"uco-observable:fromRef":{\n'
		line += CaseJson.C_TAB*3 + '"@id":":' + idFROM + '"\n'		
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:toRef":['		

		items = ''
		for i in range(len(EMAILidentifiersTO)):
			if EMAILidentifiersTO[i].strip() == '':
				pass
			else:
				if EMAILidentifiersTO[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersTO[i].strip())
					idTO = '{"@id":":' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersTO[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersTO[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idTO = '{"@id":":' + uuidEmail + '"}'
				items += items + idTO + ','
		
		# get rid of the last comma
		items = items[0:-1]
		line += items + '],\n'

		line += CaseJson.C_TAB*2 + '"uco-observable:ccRefs":['		
		items = ''
		for i in range(len(EMAILidentifiersCC)):
			if EMAILidentifiersCC[i].strip() == '':
				pass
			else:
				if EMAILidentifiersCC[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersCC[i].strip())
					idCC = '{"@id":":' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersCC[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersCC[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idCC = '{"@id":":' + uuidEmail + '"}'
				items += items + idCC + ','

		# get rid of the last comma
		items = items[0:-1]
		line += items + '],\n'

		line += CaseJson.C_TAB*2 + '"uco-observable:bccRefs":['		
		items = ''
		for i in range(len(EMAILidentifiersBCC)):
			if EMAILidentifiersBCC[i].strip() == '':
				pass
			else:
				if EMAILidentifiersBCC[i].strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(EMAILidentifiersBCC[i].strip())
					idBCC = '{"@id":":' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(EMAILidentifiersBCC[i].strip())
					uuidEmail = self.__generateTraceEmailAccount(EMAILidentifiersBCC[i].strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idBCC = '{"@id":":' + uuidEmail + '"}'
				items += items + idBCC + ','

		# get rid of the last comma
		items = items[0:-1]
		line += items + '],\n'

		body = EMAILbody.replace('"', "")
		body = body.replace('\n', ' ')		
		#--- backslash and tab chars are not accepted in JSON value
		body = body.replace('\t', ' ')
		body = body.replace('\\', ' _BS_ ')
		line += CaseJson.C_TAB*2 + '"uco-observable:body":"' + body + '",\n'		
		subject = EMAILsubject.replace('"', "")
		subject = subject.replace('\n', ' ')
		#subject = subject.replace('\t', ' ')
		subject = subject.replace('\\', ' _BS_ ')
		line += CaseJson.C_TAB*2 + '"uco-observable:subject":"' + subject + '",\n'		
		line += CaseJson.C_TAB*2 + '"uco-observable:__status":"' + EMAILstatus + '"\n'				
		line += CaseJson.C_TAB*2 + '} \n'
		line += CaseJson.C_TAB + '] \n';
		line += '}, \n';
		self.FileOut.write(line);
		self.__generateChainOfEvidence(EMAILid, uuid)

		for i in range(len(EMAILattachmentsFilename)):
			if EMAILattachmentsFilename[i].strip() == '':
				pass
			else:
				fileUuid = self.__generateTraceFile(EMAILattachmentsFilename[i], 
				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
  				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP,
  				CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP, CaseJson.C_NP)
				self.__generateTraceRelation(fileUuid, uuid, 'attachment-of', 
				'NOT_PROVIDED', 'NOT_PROVIDED')
		return uuid

	def __generateTraceEmailAccount(self, address):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer": "' + \
			CaseJson.C_NP + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:isActive":"true"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		address = address.replace('"', "'")
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:EmailAccount", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:emailAddress":"' + address + '"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + '] \n'
		line += '}, \n'
		self.FileOut.write(line)
		return uuid

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEiNode, FILEiNodeTimeM, FILEgid, FILEuid):
		
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem",\n'
		#line += CaseJson.C_TAB + '"tag":["' + FILETag + '"],\n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:File",\n'
		head, tail = os.path.split(FILEpath)
		tail = tail.replace("\\", "/")
		tail = tail.replace('"', "'")
		line += CaseJson.C_TAB*2 + '"uco-observable:fileName":"' + tail + '",\n'
		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")
		line += CaseJson.C_TAB*2 + '"uco-observable:filePath":"' + path + '",\n'
		localPath = FILElocalPath.replace("\\", "/")
		line += CaseJson.C_TAB*2 + '"uco-observable:__fileLocalPath":"' + localPath + '",\n' 		
		dotPos = tail.find('.')
		sExt = tail[dotPos:]
		line += CaseJson.C_TAB*2 + '"uco-observable:extension":"' + sExt + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:fileSystemType":"userdata (ExtX)",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:isDirectory":"false",\n'
		#line += CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"allocated",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:sizeInBytes": {\n'
		line += CaseJson.C_TAB*2 + '"@type":"xsd:long", \n'
		line += CaseJson.C_TAB*2 + '"@value":"' + FILEsize + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:createdTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + FILEtimeC + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:modifiedTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + FILEtimeM + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accessedTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + FILEtimeA + '"\n'
		line += CaseJson.C_TAB*3 + '}\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:ExtInode",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:extInode":"' + FILEiNode + '",\n' 
		line += CaseJson.C_TAB*2 + '"uco-observable:extSGID":"' + FILEgid + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:extSUID":"' + FILEuid + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:extInodeChangeTime":"' + FILEiNodeTimeM +'"'
		if  FILEsize.strip == '0':
			 line += CaseJson.C_TAB*2 + '}\n'
		else:
			line += CaseJson.C_TAB*2 + '},\n'
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"type":"uco-observable:ContentData",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:hash":[\n'
			line += CaseJson.C_TAB*3 + '{\n'
			line += CaseJson.C_TAB*3 + '"@type":"uco-types:Hash",\n'
			line += CaseJson.C_TAB*3 + '"uco-types:hashMethod":\n'
			line += CaseJson.C_TAB*4 + '{\n'
			line += CaseJson.C_TAB*4 + '"@type": "uco-vocabulary:HashNameVocab",\n'
			line += CaseJson.C_TAB*4 + '"@value": "' + FILEhashType + '"\n'
			line += CaseJson.C_TAB*4 + '},\n'
			line += CaseJson.C_TAB*3 + '"uco-types:hashValue":\n'
			line += CaseJson.C_TAB*4 + '{\n'
			line += CaseJson.C_TAB*4 + '"@type": "xsd:hexBinary",\n'
			line += CaseJson.C_TAB*4 + '"@value":"' + FILEHashValue  + '"\n'
			line += CaseJson.C_TAB*4 + '}\n'
			line += CaseJson.C_TAB*3 + '}\n'
			line += CaseJson.C_TAB*2 + '] \n'
			#line += CaseJson.C_TAB*2 +  '"uco-observable:SizeInBytes":"256"\n'
			line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n';
		line += '},\n';
		self.FileOut.write(line);
		return uuid


	def __generateTraceIdentity(self, name, familyName, birthDate):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-identity:Identity",\n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-identity:SimpleName",\n'
		line += CaseJson.C_TAB*2 + '"uco-identity:givenName":"' + name + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-identity:familyName":"' + familyName + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-identity:BirthInformation",\n'
		line += CaseJson.C_TAB*2 + '"uco-identity:birthDate":{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + birthDate + '"\n'
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + '}\n'
		line += CaseJson.C_TAB + ']\n'
		line += '},\n';
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneAccount(self, Source, Name, PhoneNum):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:isActive":"true"\n' 
		line += CaseJson.C_TAB*2 + '}, \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneAccount", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:name":"' + Name + '" \n'
		line += CaseJson.C_TAB*2 + '} \n'
		line += CaseJson.C_TAB + '] \n';
		line += '}, \n';
		self.FileOut.write(line);
		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB +  '"@type":"uco-action:Action",\n'
		line += CaseJson.C_TAB +  '"uco-action:name":"' + name + '",\n'
		line += CaseJson.C_TAB + '"uco-action:description":"' + description + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-action:startTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + startTime + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-action:endTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + endTime + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-action:ActionReferences",\n' 
		line += CaseJson.C_TAB*2 + '"uco-action:instrument":":' + idInstrument + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-action:location":":' + location + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-action:performer":":' + idPerformer + '",\n'
		line += CaseJson.C_TAB*2 + '"uco-action:object":[\n'
		line += CaseJson.C_TAB*2 + '":' + idObject + '"\n'
		line += CaseJson.C_TAB*2 + '],\n'
		line += CaseJson.C_TAB*2 + '"uco-action:result":[\n'

		n = len(listResult)
		for i in range(n - 1):
			line += CaseJson.C_TAB*2 + '":' + listResult[i] + '",';

		if n > 0:
			line += '":' + listResult[n - 1]  + '"\n'
			line += CaseJson.C_TAB*2 + ']\n'
			line += CaseJson.C_TAB*2 + '}';

		line += CaseJson.C_TAB + ']\n'
		line += '}' + endChar + '\n'
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneCall", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:callType":"' + direction + '",\n '
		line += CaseJson.C_TAB*2 + '"uco-observable:startTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + startTime + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:from":{\n'
		line += CaseJson.C_TAB*3 + '"@id":":' + idFROM + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:to":{\n'
		line += CaseJson.C_TAB*3 + '"@id":":' + idTO + '"\n'
		line += CaseJson.C_TAB*2 + '},\n'

		line += CaseJson.C_TAB*2 + '"uco-observable:duration":"' + duration + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"allocated", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:__outcome":"' + outcome + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:__status":"' + status + '" \n'
		line += CaseJson.C_TAB*2 + '}\n' 
		line += CaseJson.C_TAB + '] \n'
		line += '}, \n'
		self.FileOut.write(line);
		return uuid
	

	def __generateTracePhoneOwner(self, Source, Name, PhoneNum):
		self.phoneOwnerUuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' + self.phoneOwnerUuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Account", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:isActive":"true"\n'
		line += CaseJson.C_TAB*2 + '}, \n'
		line += CaseJson.C_TAB*2 + '{ \n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:PhoneAccount", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n'
		line += CaseJson.C_TAB*2 + '"uco-observable:name":"' + Name + '" \n'
		line += CaseJson.C_TAB*2 + '} \n'
		line += CaseJson.C_TAB + ']\n';
		line += '}, \n';
		self.FileOut.write(line);
		self.phoneNumberList.append(PhoneNum)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-investigation:ProvenanceRecord", \n'
		line += CaseJson.C_TAB*2 + '"uco-investigation:createdTime":\n'
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		line += CaseJson.C_TAB*3 + '"@value":"' + creationTime + '"\n'
		line += CaseJson.C_TAB*3 + '},\n'
		line += CaseJson.C_TAB + '"uco-investigation:description":"' + description + '",\n'
		line += CaseJson.C_TAB + '"uco-investigation:exhibitNumber":"' + exhibitNumber + '",\n' 
		line += CaseJson.C_TAB + '"uco-investigation:object":[\n'
		idx = 0
		n = len(idTracesList) - 1
		for idx in range(n):
			line += CaseJson.C_TAB*2  + '":' + idTracesList[idx] + '",'

		if n > 0:
			line += CaseJson.C_TAB*2  + '":' + idTracesList[n - 1] + '"\n'
		
		line += CaseJson.C_TAB + ']\n'
		line += '},\n'
		self.FileOut.write(line)
		return uuid


	def __generateTraceRelation(self, source, target, relation, table, offset):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:Relationship",\n'
		line += CaseJson.C_TAB + '"uco-observable:source":":' + source + '",\n'
		line += CaseJson.C_TAB + '"uco-observable:target":":' + target + '",\n'
		line += CaseJson.C_TAB + '"uco-observable:kindOfRelationship":"' + relation + '",\n'
		if not table == '':
			line += CaseJson.C_TAB + '"uco-observable:isDirectional":"True",\n'
			line += CaseJson.C_TAB + '"uco-core:facets": [\n'
			line += CaseJson.C_TAB*2 + '{\n '
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:DataRange",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:rangeOffset":"' + offset + '",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:rangeSize":"__NOT_PROVIDED" \n'
			line += CaseJson.C_TAB*2 + '},\n '
			line += CaseJson.C_TAB*2 + '{ \n'
			line += CaseJson.C_TAB*2 + '"@type": "uco-observable:TableRelation", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:name":"' + table + '"\n'
			line += CaseJson.C_TAB*2 + '}'
			line += CaseJson.C_TAB + ']'
		else:
			line += CaseJson.C_TAB + '"uco-observable:isDirectional":"True"\n'

		line += '},\n'
		self.FileOut.write(line)
		return uuid

	def __generateTraceRole(self, role):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-role:Role",\n'
		line += CaseJson.C_TAB + '"uco-role:name":"' + role + '"\n'
		line += '},\n'
		self.FileOut.write(line)
		return uuid

	def __generateTraceSms(self, SMSid, SMSstatus, SMStimeStamp, 
							SMSpartyRoles, SMSpartyIdentifiers, 
							SMSpartyNames, SMSbody, SMSsource):
		for i in range(len(SMSid)):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			for j in range(len(SMSpartyIdentifiers[i])):
				if SMSpartyIdentifiers[i][j].strip() == '':
					pass
				else:
					if SMSpartyIdentifiers[i][j] in self.phoneNumberList:
						idx = self.phoneNumberList.index(SMSpartyIdentifiers[i][j])
						userId = self.phoneNumberList[idx]
						phonePartyUuid = self.phoneUuidList[idx]
					else:
						phonePartyUuid = self.__generateTracePhoneAccount('_MOBILE_NETWORK_OPERATOR', 
							SMSpartyNames[i][j], SMSpartyIdentifiers[i][j])	
				
					phoneUuidTo = ''
	        		# Party with Role=TO can be more than one
					if SMSpartyRoles[i][j] == 'To':
						phoneUuidFrom = self.phoneOwnerUuid
						phoneUuidTo += '":' + phonePartyUuid + '"' + ','
					else:
						phoneUuidFrom = phonePartyUuid
						phoneUuidTo = '":' + self.phoneOwnerUuid + '"'
			if phoneUuidTo == self.phoneOwnerUuid:
				phoneUuidTo = '{"@id":":' + self.phoneOwnerUuid + '"}'	
			else:
			# get rid of the last comma if the field is not empty
				if phoneUuidTo == '':
					pass
				else:
					if phoneUuidTo[-1] == ',':
						phoneUuidTo = phoneUuidTo[0:-1]

			uuid = CaseJson.__createUUID()
			line = '{\n'
			line += CaseJson.C_TAB + '"@id":":' + uuid + '", \n'
			line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
			line += CaseJson.C_TAB + '"uco-core:facets":[ \n'
			line += CaseJson.C_TAB*2 + '{ \n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:Message", \n' 
			line += CaseJson.C_TAB*2 + '"uco-observable:application":"' + SMSsource[i] + '", \n' 
			body = SMSbody[i].replace('\n', ' ')
			body = body.replace('"', "'")
			body = body.replace('\t', ' ')
			body = body.replace("\\'", "'")
			body = body.replace("\\", "")
			line += CaseJson.C_TAB*2 + '"uco-observable:messageText":"' + body + '", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:__status":"' + SMSstatus[i] + '", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:from":{\n'
			line += CaseJson.C_TAB*3 + '"@id":":' + phoneUuidFrom + '"\n'
			line += CaseJson.C_TAB*2 + '},\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:to":[' + phoneUuidTo + '], \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:sentTime":{\n'
			line += CaseJson.C_TAB*3 + '"@type": "xsd:dateTime", \n' 
			line += CaseJson.C_TAB*3 + ' "@value": "' + SMStimeStamp[i] + '"\n'
			line += CaseJson.C_TAB*3 + '} \n'	
			line += CaseJson.C_TAB*2 + '} \n'
			line += CaseJson.C_TAB + '] \n'
			line += '}, \n'		
			self.FileOut.write(line)
			self.__generateChainOfEvidence(SMSid[i], uuid)

	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
		line += CaseJson.C_TAB + '"uco-core:facets":[\n'
		line += CaseJson.C_TAB*2 + '{\n'
		line += CaseJson.C_TAB*2 + '"@type":"uco-observable:MessageThread",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:displayName":"NOT_PROVIDED",\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:messages":{\n'
		line += CaseJson.C_TAB*2 + '"olo:length":"' + str(len(chatThread)) + '",\n'
		line += CaseJson.C_TAB*2 + '"olo:slot":[\n'

		n = len(chatThread)
		for i in range(n - 1):
			line += CaseJson.C_TAB*3 + '{\n'
			line += CaseJson.C_TAB*4 + '"olo:index":"' + str(i + 1) + '",\n'
			line += CaseJson.C_TAB*4 + '"olo:item": {\n'
			line += CaseJson.C_TAB*5 + '"@id":":' + chatThread[i] + '"\n'
			line += CaseJson.C_TAB*4 + '}\n'
			line += CaseJson.C_TAB*3 + '},\n'
		
		line += CaseJson.C_TAB*3 + '{\n'
		line += CaseJson.C_TAB*4 + '"olo:index":"' + str(n) + '",\n'
		line += CaseJson.C_TAB*4 + '"olo:item": {\n'
		line += CaseJson.C_TAB*5 + '"@id":":' + chatThread[n - 1] + '"\n'
		line += CaseJson.C_TAB*4 + '}\n'
		line += CaseJson.C_TAB*3 + '}\n'

		line += CaseJson.C_TAB*3 + ']\n'
		line += CaseJson.C_TAB*2 + '},\n'
		line += CaseJson.C_TAB*2 + '"uco-observable:participants":[\n'

		n = len(chatIdAccountList)
		
		for i in range(n - 1):
			line += CaseJson.C_TAB*3 + '{"@id":":' + chatIdAccountList[i] + '"},\n'

		if n > 0:
			line += CaseJson.C_TAB*3  + '{"@id":":' + chatIdAccountList[n - 1] + '"}]\n' 
		
		line += CaseJson.C_TAB*2 + '}\n'
		line += CaseJson.C_TAB + ']\n'
		line += '},\n'
		self.FileOut.write(line)
		#self.__generateChainOfEvidence(chatTraceId, uuid)
		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		uuid = CaseJson.__createUUID()
		line = '{ \n'
		line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
		line += CaseJson.C_TAB + '"@type":"uco-tool:Tool", \n'
		line += CaseJson.C_TAB + '"uco-tool:name":"' + name + '",\n' 
		line += CaseJson.C_TAB + '"uco-tool:toolType":"' + type + '",\n'
		line += CaseJson.C_TAB + '"uco-tool:creator":"' + vendor + '",\n'
		line += CaseJson.C_TAB + '"uco-tool:version":"' + version + '"\n';

		if len(confList) > 0:  
			line += line + ',\n'
			line += CaseJson.C_TAB + '"uco-core:facets":[\n'
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-tool:ConfigurationSettingType",\n'
			line += CaseJson.C_TAB*2 + '"configurationSetting":[\n'
			n = len(TOOLconfList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += CaseJson.C_TAB*3 + '{\n'
				line += CaseJson.C_TAB*3 + '"@type":"uco-tool:ConfigurationSettingType",\n'
				line += CaseJson.C_TAB*3 + '"uco-tool:itemName":"' + listItems[0] + '",\n'
				line += CaseJson.C_TAB*3 + '"uco-tool:itemValue":"' + listItems[1] + '"\n'
				line += CaseJson.C_TAB*3 + '},\n' 
    
			listItems.clear()
			listItems += confList[n].split('@')
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:ConfigurationSetting",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:itemName":"' + listItems[0] + '",\n' 
			line += CaseJson.C_TAB*2 + '"uco-observable:itemValue":"' + listItems[1] + '"\n'
			line += CaseJson.C_TAB*2 + '}\n'
			line += CaseJson.C_TAB*2 + ']\n'
			line += CaseJson.C_TAB + '}\n'
			line += CaseJson.C_TAB + ']\n'
			line += '}\n';
		else:
			line += '},\n';

		self.FileOut.write(line);
		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited):
		for i in range(len(WEB_PAGEid)):
			uuid = CaseJson.__createUUID()
			line = '\n{ \n'
			line += CaseJson.C_TAB + '"@id":":' +  uuid + '", \n'
			line += CaseJson.C_TAB + '"@type":"uco-observable:CyberItem", \n'
			line += CaseJson.C_TAB + '"uco-core:facets":[\n'
			line += CaseJson.C_TAB*2 + '{\n'
			line += CaseJson.C_TAB*2 + '"@type":"uco-observable:WebHistory", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:source":"' 
			line += WEB_PAGEsource[i] + '", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:url":"' 
			line += WEB_PAGEurl[i] + '", \n'
			line += CaseJson.C_TAB*2 + '"uco-observable:title":"' 
			title = WEB_PAGEtitle[i].replace('"', '')
			line += title + '",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:visitCount":"' 
			line += WEB_PAGEvisitCount[i] + '",\n' 
			line += CaseJson.C_TAB*2 + '"uco-observable:visitTime":\n'
			line += CaseJson.C_TAB*3 + '{\n'
			line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
			line += CaseJson.C_TAB*3 + '"@value":"__NOT_PROVIDED"\n'
			line += CaseJson.C_TAB*3 + '},\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:typedCount":"0",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:duration":"NOT_PROVIDED",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:transitiontype":"NOT_PROVIDED",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:searchterm":"NOT_PROVIDED",\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:lastVisited":\n'
			line += CaseJson.C_TAB*3 + '{\n'
			line += CaseJson.C_TAB*3 + '"@type":"xsd:dateTime",\n'
			line += CaseJson.C_TAB*3 + '"@value":"' + WEB_PAGElastVisited[i] + '"\n'
			line += CaseJson.C_TAB*3 + '},\n'
			line += CaseJson.C_TAB*2 + '"uco-observable:__status":"' 
			line += WEB_PAGEstatus[i] + '", \n' 
			line += CaseJson.C_TAB*2 + '"uco-observable:allocationStatus":"' 
			line += 'NOT_PROVIDED' + '" \n'
			line += CaseJson.C_TAB*2 + '}\n'
			line += CaseJson.C_TAB + ']\n'  						
			line += '},\n'  						
			self.FileOut.write(line);
			
			#last web page item, endChar is not "," (default) but " "
			if i == len(WEB_PAGEid) - 1:
				self.__generateChainOfEvidence(WEB_PAGEid[i], uuid, ' ')

	#not used anymore, every time the field Source is extracted
	# an uco-observable:Application item is created
	def storeUserAccount(self, U_ACCOUNTsource, U_ACCOUNTname,
			U_ACCOUNTusername):
		for i in range(len(U_ACCOUNTsource)):
			idAppName = self.__generateTraceAppName(U_ACCOUNTsource[i])
			self.appNameList.append(U_ACCOUNTsource[i])
			#self.appAccountNameList.append(U_ACCOUNTname[i])
			#self.appAccountUsernameList.append(U_ACCOUNTusername[i])
			self.appIDList.append(idAppName)


	def writeCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
				CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
				CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
				CALLidentifiersFROM):
		self.__generateTraceCall(CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM)

	def writeExtraInfo(self, EXTRA_INFOdictPath, EXTRA_INFOdictSize, EXTRA_INFOdictTableName, 
				EXTRA_INFOdictOffset, EXTRA_INFOdictNodeInfoId):
		self.EXTRA_INFOdictPath = EXTRA_INFOdictPath
		self.EXTRA_INFOdictSize = EXTRA_INFOdictSize
		self.EXTRA_INFOdictTableName = EXTRA_INFOdictTableName
		self.EXTRA_INFOdictOffset = EXTRA_INFOdictOffset
		self.EXTRA_INFOdictNodeInfoId = EXTRA_INFOdictNodeInfoId		

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i in range(len(CONTACTname)):
			for j in range(len(CONTACTphoneNums[i])):
				if CONTACTphoneNums[i][j] in self.phoneNumberList:					
					pass
				else:
					self.phoneNumberList.append(CONTACTphoneNums[i][j])
					self.phoneNameList.append(CONTACTname[i])
					uuid = self.__generateTracePhoneAccount('_MOBILE_NETWORK_OPERATOR', CONTACTname[i], CONTACTphoneNums[i][j])
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		self.__generateHeader()

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber):
		self.phoneOwnerNumber = phoneOwnerNumber
		self.__generateTracePhoneOwner('_PHONE_OWNER_MOBILE_NETWORK_OPERATOR', '_PHONE_OWNER_name', phoneOwnerNumber)

	def writeFiles(self, FILEid, FILEpath, FILEsize, FILEmd5, FILETag, 
					FILEtimeCreate, FILEtimeModify, FILEtimeAccess, FILElocalPath, 
                    FILEiNodeNumber, FILEiNodeTimeM, FILEownerGID, FILEownerUID):
			self.FILEid = FILEid
			for i in range(len(FILEid)):			
				uuid = self.__generateTraceFile(FILEpath[i], FILEsize[i], 
					'MD5', FILEmd5[i],	FILETag[i], FILEtimeCreate[i], FILEtimeModify[i], 
					FILEtimeAccess[i], FILElocalPath[i], FILEiNodeNumber[i], FILEiNodeTimeM[i],
					FILEownerGID[i], FILEownerUID[i])

				self.FILEuuid[FILEid[i]] = uuid

	def writeChat(self, CHATid, CHATstatus, CHATsource, CHATpartyIdentifiers, CHATpartyNames, 
                CHATmsgIdentifiersFrom, CHATmsgNamesFrom, CHATmsgIdentifiersTo, 
                CHATmsgNamesTo, CHATmsgBodies, CHATmsgStatuses, CHATmsgOutcomes,
                CHATmsgTimeStamps, CHATmsgAttachmentFilenames, CHATmsgAttachmentUrls):		
		for i in range(len(CHATid)):
			if CHATsource[i].strip().lower() in self.appNameList: 
				idx = self.appNameList.index(CHATsource[i].strip().lower())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(CHATsource[i].strip())
				self.appNameList.append(CHATsource[i].strip())
				self.appIDList.append(idAppIdentity)
			
			CHATidAccountList = []
			for j in range(len(CHATpartyIdentifiers[i])):				
				if CHATpartyIdentifiers[i][j].strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(CHATpartyIdentifiers[i][j].strip())
					CHATidAccountList.append(self.CHATaccountIdList[idx])
				else:
					self.CHATparticipantsNameList.append(CHATpartyNames[i][j].strip())
					idChatAccount = self.__generateTraceChatAccount(CHATsource[i].strip(),
						CHATpartyIdentifiers[i][j].strip(), CHATpartyNames[i][j].strip(),
						idAppIdentity)
					self.CHATparticipantsIdList.append(CHATpartyIdentifiers[i][j].strip())
					self.CHATaccountIdList.append(idChatAccount)
					CHATidAccountList.append(idChatAccount)

			appSource = CHATsource[i].strip().lower()
			# if the Source is whatsapp, then the owner's whatsapp
			# account must be part of the participants of the Chat
			if appSource == 'whatsapp':
				if 'whatsapp' in self.appNameList:
					idx = self.appNameList.index('whatsapp')
				else:
					idApp = self.__generateTraceAppName('whatsapp')
					#idIdentity = self.__generateTraceAppIdentity('WhatsApp')
					self.appNameList.append('whatsapp')
					#self.appAccountUsername.append(idIdentity)
					self.appIDList.append(idApp)
					idx = self.appNameList.index('whatsapp')

				#idAppWhatsApp = self.appAccountUsername[idx]
				idAppWhatsApp = self.appIDList[idx]
				idPhoneOwner = self.phoneOwnerNumber + '@s.whatsapp.net'			
				if idPhoneOwner in self.CHATparticipantsIdList:
					pass
				else:
					self.CHATparticipantsNameList.append('PHONE_OWNER_NAME')
					idChatAccount = self.__generateTraceChatAccount('WhatsApp',
					idPhoneOwner, 'PHONE_OWNER_NAME', idAppWhatsApp)
					self.CHATparticipantsIdList.append(idPhoneOwner)
					self.CHATaccountIdList.append(idChatAccount)

				# the owner's phone num must be always part of the 
				# participants Chat account
				idx = self.CHATparticipantsIdList.index(idPhoneOwner)
				chatAccountPhoneOwner = self.CHATaccountIdList[idx]
				if chatAccountPhoneOwner in CHATidAccountList:
					pass
				else:
					CHATidAccountList.append(chatAccountPhoneOwner)
			
			CHATthread = []
# CHATmsgBodies[i] is the list of the messages of the same thread, the j index
# iterates over all these messages
			for j in range(len(CHATmsgBodies[i])):				
# IdentifiersTo may contain more than one ID, separated by ###. This occurs
# when a message is sent to a group and more than one recipient is involved
				CHATmsgTo = CHATmsgIdentifiersTo[i][j].split('###')	
# if IdentifiersTo is empty, there is only a recipient: the phone owner number								
				CHATmsgFrom = CHATmsgIdentifiersFrom[i][j].strip() 

# if Identifiers TO is empty, the array CHATpartyIdentifiers must
# be iterated to find the right Party
				
				if CHATmsgTo[0].strip() == '':
					for k in range(len(CHATpartyIdentifiers[i])):
						if CHATpartyIdentifiers[i][k] == CHATmsgFrom:
							pass
						else:
							CHATmsgTo[0] = CHATpartyIdentifiers[i][k]
							break
					direction = 'Incoming'
				else:			
					direction = 'Outgoing'
				
# if Identifiers FROM is empty, the array CHATpartyIdentifiers must
# be iterated to find the right Party
				
				if CHATmsgFrom == '':
					for k in range(len(CHATpartyIdentifiers[i])):
						if CHATpartyIdentifiers[i][k] in CHATmsgTo:
							pass
						else:
							CHATmsgFrom = CHATpartyIdentifiers[i][k]
							break
				
				chatUuid = self.__generateTraceChat(CHATmsgBodies[i][j], idAppIdentity, 
					CHATmsgTimeStamps[i][j], CHATmsgFrom, 
					CHATmsgTo, CHATmsgStatuses[i][j], CHATmsgOutcomes[i][j],
					direction, CHATmsgAttachmentFilenames[i][j], 
					CHATmsgAttachmentUrls[i][j])
				CHATthread.append(chatUuid)

			# if there are not messages for this Chat or no ChatAccount has been
			# generated, the ThreadMessage is not generated. Moreover the Chain of
			# evidence is built upon the ThreadUuid
			if (len(CHATthread) == 0) or (len(CHATidAccountList) == 0):
				pass
			else:
				uuidThread = self.__generateThreadMessages(CHATid[i], CHATthread, 
								CHATidAccountList)
				self.__generateChainOfEvidence(CHATid[i], uuidThread)

	def writeEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
                EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename):
		for i in range(len(EMAILid)):
			self.__generateTraceEmail(EMAILid[i], EMAILstatus[i], EMAILsource[i],
				EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited):
		self.__generateTraceWebPages(WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited)

	def writeSms(self, SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles,
					SMSpartyIdentifiers, SMSpartyNames, SMSbody, SMSsource):
		self.__generateTraceSms(SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles, 
					SMSpartyIdentifiers, SMSpartyNames, SMSbody, SMSsource)

	def writeContextUfed(self, ufedVersionText, deviceExtractionStartTime, 
		deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
		deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextUfed(ufedVersionText, deviceExtractionStartTime, 
			deviceAcquisitionStartTime, deviceAcquisitionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


