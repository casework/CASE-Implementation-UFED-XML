#---	class UFEDtoJSON.py

import uuid
import os
import re

class UFEDtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	C_TAB = '\t'

# default value for string value not provided
#
	C_NP = ''  				

# default value for integer value not provided
#
	C_INT = '0'				

# default value for date value not provided
#
	C_DATE = '1900-01-01T08:00:00'				

# default value for Hash Method value not provided
#
	C_HASH_M = 'MD5' 	

# default value for Hash Method value not provided
#
	C_HASH_V = '1' * 76 	

# default value for the property referrerUrl of the URLHistoryFacet class
#
	C_REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
#
	C_LOCATION = 'Unknown location'


	def __init__(self, fileOut, appName, appUserName, appUserAccount):
	# to be defined
		self.FileOut = fileOut
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []

		self.EMAILaccountIdList = []
		self.EMAILaddressList = []
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEpath = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.U_ACCOUNTapp = appName
		self.U_ACCOUNTappUserName = appUserName
		self.U_ACCOUNTappUserAccount = appUserAccount

		self.UrlList = []
		self.UrlIDList = []

		self.LocationList = []
		self.LocationIDList = []

		self.SYS_MSG_ID = ''

		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def __cleanDate(self, originalDate):
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}

		originalDate = originalDate.strip()
#---	the xsd:dateTime must have the format YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		

		if 	originalDate == '':
			return UFEDtoJSON.C_DATE

		for k,v in aMonths.items():
			if originalDate.find(k) > -1:
				originalDate = originalDate.replace(k, v)
				break

		originalDate = originalDate.replace("/", "-")
		originalDate = originalDate.replace("(", "-")
		originalDate = originalDate.replace(")", "-")
		originalDate = originalDate.replace(' ', 'T', 1)
		originalDate = originalDate.replace('UTC', '')
		originalDate = originalDate.replace('AM', '')
		originalDate = originalDate.replace('PM', '')
		if re.search('^[0-9]{4}', originalDate):
			pass
		else:
			originalDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', originalDate)
			originalDate = str(originalDate[6:10]) + originalDate[2:6] + originalDate[0:2] + \
				originalDate[10:] 

		startTZ = originalDate.find("+")
		if startTZ > -1:
			originalDate = originalDate[:startTZ]

		firstChars = originalDate[:10]
		firstChars = firstChars.replace(".", "-")
		originalDate = firstChars + originalDate[10:]

		originalDate = originalDate.strip()

		if originalDate[-1] == '-':
			originalDate = originalDate[0:-1]

		originalDate = originalDate.replace('.000', '')
		originalDate = originalDate.replace('.', ':')

		if re.search('T\d{2}\.', originalDate):
			originalDate = originalDate.replace('.', ':')

		#print(f'*DEBUG* before replacing, dateTime\t {originalDate}')
		if re.search('(\d{2}:\d{2}:\d{2})$', originalDate):
			pass
		else:
			originalDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', originalDate)

		if re.search('T(\d):', originalDate):
			originalDate = re.sub('T(\d):', 'T0\g<1>:', originalDate)

		if re.search(':(\d):', originalDate):
			originalDate = re.sub(':(\d):', ':0\g<1>:', originalDate)

		if re.search(':(\d)$', originalDate):
			originalDate = re.sub(':(\d)$', ':0\g<1>', originalDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', originalDate):
			originalDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', originalDate)


		return originalDate.strip()	

	def ___generateContextUfed(self, ufedVersion, deviceReportCreateTime,
			deviceExtractionStartTime, deviceExtractionEndTime, examinerName, 
		deviceBluetoothAddress, deviceId, devicePhoneModel, 
		deviceOsType, deviceOsVersion, devicePhoneVendor, 
		deviceMacAddress, deviceIccid, deviceImsi, deviceImei, 
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('UFED_PA', 'Acquisition', 
			'Cellebrite', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '');

		# generate Trace/Device for the mobile phone
		idDevice = self.__generateTraceDevice(deviceMacAddress, deviceId, devicePhoneModel,
			deviceOsType, deviceOsVersion, devicePhoneVendor, '',
			deviceIccid, deviceImsi, deviceImei, deviceBluetoothAddress)
		
#---	the XML report contains the attribute DeviceInfoExtractionStartDateTime 
#			that is the Acquisition Start Date and similarly for the Acquisition
#			End Date, The CreationReportDate is the Start and the End of the Extraction 
#			Forensic Action
#


#---	generate Trace/Provenance_Record for the mobile device
		#
		idDeviceList = []
		idDeviceList.append(idDevice)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			'', deviceExtractionStartTime) 
		
#---	generate Trace/File for each file extracted by the Acuisition action
#			idFileList contains the uuid of these files and it is used for
#			creating the Provenance_Record of the Result/Output of the Acquisition 
# 		action. 
#			2021-08-02: actually the XML report doesn't include the Acquisition info
#		
		idFilesAcquisition = []
		for i, img_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], 'Uncategorized', '', '', '', '',
				'', '', '', '', '', '', '', '', '', '', '')  
				 
			else:
				idFileAcquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], 'Uncategorized', 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '') 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
        	'Acquisition files', '', deviceExtractionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)
		
		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceExtractionStartTime, 
			deviceExtractionEndTime, idTool, '', 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'', deviceReportCreateTime);
        
		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceReportCreateTime,
			deviceReportCreateTime, idTool, '', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, IdTrace, uuidTrace, endChar=','):
#---	Search traceId in EXTRA_INFOdictNodeInfo a dictionary whose keys are the id
#			that represents the link between a Trace and its file(s)
#		
		table = self.EXTRA_INFOdictTableName.get(IdTrace, '_?TABLE')
		offset = self.EXTRA_INFOdictOffset.get(IdTrace, '_?OFFSET')

#---	This is the case where the infoNode sub element of extraInfo contains the id 
#			reference to the file. More then one infoNode can exist, the value of the key 
#			contains the id file separated by @@
#		
		if self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '').strip() == '':
			path = self.EXTRA_INFOdictPath.get(IdTrace, '_?PATH')
			size = self.EXTRA_INFOdictSize.get(IdTrace, '_?SIZE')
			if path != '_?PATH':
				uuidFile = self.__generateTraceFile(path, size, '', 
						'', 'Uncategorized', '', '', '', '', '', 
						'', '', '', '', '', '', '', '', '', '')

				self.FILEuuid[IdTrace] = uuidFile
				self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
					table, offset);
		else:
			nodeInfoIdList = self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '@@@').split('@@@')
			for node in nodeInfoIdList:
				if node.strip() != '': 
					if node in self.FILEid: 
						#idFile = self.FILEid.index(node)
						#uuid = FILEuuid.get(idFile, '_?UUID')
						uuidFile = self.FILEuuid.get(node, '_?UUID')
						self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
							table, offset);
					else:
						print ('nodeInfo ' + node + ' not found')
		


	def __generateHeader(self):
		uuid = UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
				UFEDtoJSON.C_TAB + '"@context": { \n', \
				UFEDtoJSON.C_TAB*2 + '"@vocabulary": "http://caseontology.org/core#", \n', \
				UFEDtoJSON.C_TAB*2 + '"case-investigation": "https://ontology.caseontology.org/case/investigation#", \n', \
				UFEDtoJSON.C_TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n', \
				UFEDtoJSON.C_TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-action": "https://unifiedcyberontology.org/ontology/uco/action#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-core": "https://unifiedcyberontology.org/ontology/uco/core#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-identity": "https://unifiedcyberontology.org/ontology/uco/identity#",\n', \
				UFEDtoJSON.C_TAB*2 + '"uco-role": "https://unifiedcyberontology.org/ontology/uco/role#",\n', \
				UFEDtoJSON.C_TAB*2 + '"uco-location": "https://unifiedcyberontology.org/ontology/uco/location#",\n', \
				UFEDtoJSON.C_TAB*2 + '"uco-observable": "https://unifiedcyberontology.org/ontology/uco/observable#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-tool": "https://unifiedcyberontology.org/ontology/uco/tool#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-types": "https://unifiedcyberontology.org/ontology/uco/types#", \n', \
				UFEDtoJSON.C_TAB*2 + '"uco-vocabulary": "https://unifiedcyberontology.org/ontology/uco/vocabulary#", \n', \
#---	OLO is a method for representing lists, CASE didn't really need to 
#			implement itself, implementing ordered lists in an OWL 2 DL compliant 
#			syntax.				
#				
				UFEDtoJSON.C_TAB*2 + '"olo": "http://purl.org/ontology/olo/core#", \n', \
				UFEDtoJSON.C_TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n', \
				UFEDtoJSON.C_TAB*2 + '},\n', \
				'"@id": ":bundle-' + uuid + '", \n', \
				'"@type": "uco-core:Bundle",\n', \
				'"uco-core:specVersion": "CASE 0.4 - UCO 0.6",\n', \
				'"uco-core:description": "Extraction from XML report generated by UFED PA",\n', \
				'"uco-core:object": [\n'])
		self.FileOut.write(line)

	def __generateLastLine(self):
		line = UFEDtoJSON.C_TAB + '] \n }'
		self.FileOut.write(line)

	def __generateTraceAppAccount(self, source, name, identifier, idApp, idIdentity):
		name = name.replace('"', ' ')
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + idIdentity + '", \n'
			UFEDtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier":"' + identifier + '", \n' , \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:isActive":true \n', \
			UFEDtoJSON.C_TAB*2 + '}, \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:ApplicationAccountFacet", \n' , \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:application":\n', \
			UFEDtoJSON.C_TAB*4 + '{\n', \
			UFEDtoJSON.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			UFEDtoJSON.C_TAB*4 + '}\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:DigitalAccountFacet", \n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:displayName":"' + name + '"\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + ']\n', \
			'}, \n'])
		self.FileOut.write(line);
		return uuid

	def __generateTraceAppSystemMessageNotFound(self, name, identifier):
		name = name.replace('"', ' ')
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + idIdentity + '", \n'
			UFEDtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier":"' + identifier + '", \n' , \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:isActive":true \n', \
			UFEDtoJSON.C_TAB*2 + '}, \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:DigitalAccountFacet", \n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:displayName":"' + name + '"\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + ']\n', \
			'}, \n'])
		self.FileOut.write(line);
		return uuid
	
	def __generateTraceAppName(self, appName):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:ApplicationFacet", \n', \
			UFEDtoJSON.C_TAB*2 + '"uco-core:name": "' + appName + '"\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:IdentityFacet", \n', \
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n', \
			UFEDtoJSON.C_TAB*2 + '{ \n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:OrganizationFacet", \n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:orgName":"' + appName + '" \n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line);
		return uuid


	def __getMaxLenCallElement(self, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLidentifiersTO, 
					CALLidentifiersFROM):
		
		maxLen = len(CALLrolesTO)
		
		if len(CALLrolesFROM) > maxLen:
			maxLen = len(CALLrolesFROM)

		if len(CALLnamesTO) > maxLen:
			maxLen = len(CALLnamesTO)

		if len(CALLnamesFROM) > maxLen:
			maxLen = len(CALLnamesFROM)

		if len(CALLidentifiersTO) > maxLen:
			maxLen = len(CALLidentifiersTO)

		if len(CALLidentifiersFROM) > maxLen:
			maxLen = len(CALLidentifiersFROM)

		return maxLen




	def writeCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM):
		
#---	each kind of phone call, further the traditional ones, are
#			processed, so the phonePattern is not necessary any more
#	
		phonePattern = '^\+?[0-9]+$'	# phone number pattern
		
		for i, call_id in enumerate(CALLid):
			
#---	there are two Parties, each of them with their own role
#						
			idPartyTO = ''
			idPartyFROM = ''
			idParty = ''
			nameParty =''
			
			maxLen = self.__getMaxLenCallElement(CALLrolesTO[i], CALLrolesFROM[i], 
					CALLnamesTO[i], CALLnamesFROM[i], CALLidentifiersTO[i], 
					CALLidentifiersFROM[i])
			
#---	all these arrays should have the same size, the check fill in the values.
#		if this is not the case, the loops make the size the same for all arrays
#
			for j in range(maxLen - len(CALLrolesTO[i])):
				CALLrolesTO[i].append('')
			
			for j in range(maxLen - len(CALLrolesFROM[i])):
				CALLrolesFROM[i].append('')
			
			for j in range(maxLen - len(CALLnamesTO[i])):
				CALLnamesTO[i].append('')
			
			for j in range(maxLen - len(CALLnamesFROM[i])):
				CALLnamesFROM[i].append('')
			
			for j in range(maxLen - len(CALLidentifiersTO[i])):
				CALLidentifiersTO[i].append('')
			
			for j in range(maxLen - len(CALLidentifiersFROM[i])):
				CALLidentifiersFROM[i].append('')
			
			if maxLen == 0:
				CALLrolesTO[i].append('')
				CALLrolesFROM[i].append('')
				CALLnamesTO[i].append('')
				CALLnamesFROM[i].append('')
				CALLidentifiersTO[i].append('')
				CALLidentifiersFROM[i].append('')

			if (len(CALLrolesFROM[i]) > 1):
				nameParty = ''
				if CALLrolesFROM[i][0].strip() == '':					
					idPartyFROM = CALLidentifiersFROM[i][1]
					nameFROM = CALLnamesFROM[i][1]
					idPartyTO 	= CALLidentifiersTO[i][0]
					nameTO = CALLnamesTO[i][0]
					nameParty = nameTO
				else:
					idPartyFROM = CALLidentifiersFROM[i][0]
					nameFROM = CALLnamesFROM[i][0]
					idPartyTO 	= CALLidentifiersTO[i][1]
					nameTO = CALLnamesTO[i][1]
			else:					
					if CALLrolesFROM[i][0].strip() == '':
						idPartyFROM = self.phoneOwnerNumber
						nameFROM = 'PHONE OWNER'
						idPartyTO		= CALLidentifiersTO[i][0]
						idParty = idPartyTO
						nameTO = CALLnamesTO[i][0]
						nameParty = nameTO
					else:						
						idPartyFROM		= CALLidentifiersFROM[i][0]
						idParty = idPartyFROM
						idPartyTO = self.phoneOwnerNumber
						nameFROM = CALLnamesFROM[i][0]
						nameParty = nameFROM
						nameTO = 'PHONE OWNER'
						
			#print(f'#CALL {i}, nameTO: {nameTO}, nameFROM: {nameFROM}, idParty: {idParty.strip()}')
			resPattern = re.match(phonePattern, idParty.strip())

			if resPattern:
				if idPartyTO in self.phoneNumberList:
					idx = self.phoneNumberList.index(idPartyTO)
					uuidPartyTO = self.phoneUuidList[idx]
				else:	
	# if the mobile operator will be available in the XML report, it will be possible to 	
	#	define an object uco-identity:Identity related to the organisation. At the moment
	# the varibale is set to empty, so no the property uco-observable:accountIssuer is not 
	# included in the	uco-observable:PhoneAccount				
					mobileOperator = ""
					uuidPartyTO = self.__generateTracePhoneAccount(mobileOperator, 
						nameTO, idPartyTO)

				if idPartyFROM in self.phoneNumberList:
					idx = self.phoneNumberList.index(idPartyFROM)
					uuidPartyFROM = self.phoneUuidList[idx]
				else:	
	# if the mobile operator will be available in the XML report, it will be possible to 	
	#	define an object uco-identity:Identity related to the organisation. At the moment
	# the varibale is set to empty, so no the property uco-observable:accountIssuer is not 
	# included in the	uco-observable:PhoneAccount				
					mobileOperator = ""
					uuidPartyFROM = self.__generateTracePhoneAccount(mobileOperator, 
						nameFROM, idPartyFROM)

			else:
				if CALLsource[i].strip() in self.appNameList: 
					idx = self.appNameList.index(CALLsource[i].strip())
					idAppName = self.appNameList[idx]
					idAppIdentity = self.appIDList[idx]
				else:
					idAppIdentity = self.__generateTraceAppName(CALLsource[i].strip())
					self.appNameList.append(CALLsource[i].strip())
					self.appIDList.append(idAppIdentity)

				if idPartyFROM.strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(idPartyFROM.strip())
					uuidPartyFROM = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(nameFROM.strip())
					uuidPartyFROM = self.__generateTraceChatAccount(CALLsource[i].strip(),
						idPartyFROM.strip(), nameFROM.strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(idPartyFROM.strip())
					self.CHATaccountIdList.append(uuidPartyFROM)
				
				if idPartyTO.strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(idPartyTO.strip())
					uuidPartyTO = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(nameTO.strip())
					uuidPartyTO = self.__generateTraceChatAccount(CALLsource[i].strip(),
						idPartyTO.strip(), nameTO.strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(idPartyTO.strip())
					self.CHATaccountIdList.append(uuidPartyTO)
				
			
			if CALLdirection[i].lower() == 'incoming':
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartyFROM, uuidPartyTO, CALLduration[i],
                           CALLstatus[i], CALLoutcome[i])
			else:
				uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
					CALLtimeStamp[i], uuidPartyTO, uuidPartyFROM, CALLduration[i],
                           CALLstatus[i], CALLoutcome[i])
			self.__generateChainOfEvidence(call_id, uuid)


	def __generateTraceChatAccount(self, issuer, partyId, partyName, idApp):
		partyName = partyName.replace('"', ' ')
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		partyId = partyId.replace('"', '')
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:AccountFacet", \n', \
		# CASE 0.4 indicates a id reference to an Object that contains only the name of the App!
		#line += UFEDtoJSON.C_TAB*3 + '"uco-observable:accountIssuer": "' + issuer + '",\n'		
		# in CASE 0.4 applicationIdentifier --> accountIdentifier
		#line += UFEDtoJSON.C_TAB*3 + '"uco-observable:applicationIdentifier": "' + partyId + '",\n' 
			UFEDtoJSON.C_TAB*3 + '"uco-observable:accountIdentifier": "' + partyId + '",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:isActive":true\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:ApplicationAccountFacet",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:application":\n', \
			UFEDtoJSON.C_TAB*4 + '{\n', \
			UFEDtoJSON.C_TAB*5 + '"@id":"' + idApp + '"\n', \
			UFEDtoJSON.C_TAB*4  + '}\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:DigitalAccountFacet",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:displayName":"' + partyName + '"\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
		
		TOlist = ''
		for item in idToList:
			if item in self.CHATparticipantsIdList:
				idx = self.CHATparticipantsIdList.index(item)
				TOlist += '{"@id":"' + self.CHATaccountIdList[idx] + '"},'
			else:
				TOlist += '{"@id":"' + self.phoneOwnerUuid + '"},'

		TOlist = TOlist[0:-1] 
		if idFrom in self.CHATparticipantsIdList:
			idx = self.CHATparticipantsIdList.index(idFrom)
			FROMitem = self.CHATaccountIdList[idx]
		else:
			if self.SYS_MSG_ID == '':
				FROMitem = self.__generateTraceAppSystemMessageNotFound(idFrom,
					'ID ' + idFrom + ' NOT_FOUND')
				self.SYS_MSG_ID = FROMitem
			else:
				FROMitem = self.SYS_MSG_ID

				#FROMitem = 'ID ' + idFrom + ' NOT_FOUND'
		
		body = body.replace('"', "'")
		body = body.replace('\n', ' ')
		body = body.replace('\t', ' ')
		body = body.replace("\\'", "'")
		body = body.replace("\\", "")
		TOlist = TOlist.replace('\t', ' ')

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		
		timeStamp = self.__cleanDate(timeStamp)


		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageFacet", \n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:messageText":"' + body + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:application":\n', \
			UFEDtoJSON.C_TAB*3 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idApplication + '"\n', \
			UFEDtoJSON.C_TAB*3 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:sentTime":\n', \
			UFEDtoJSON.C_TAB*3 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			UFEDtoJSON.C_TAB*3 + '"@value":"' + timeStamp + '"\n', \
			UFEDtoJSON.C_TAB*3 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:from":{\n', \
			UFEDtoJSON.C_TAB*3 + '"@id":"' + FROMitem + '"\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:to":[\n', \
			UFEDtoJSON.C_TAB*3 + TOlist + '],\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '",\n', \
#	CASE 0.2/UCO 0.4 compliant, no uco-observable:out property in Observable
#
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '",\n'
			UFEDtoJSON.C_TAB*2 + '"uco-observable:messageType":"' + direction + '"\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line)
		
		#each Message, within a specific Chat can have more than one attachment,
		# both the Filenames and the Urls of the Attachment are separated by
		# a triple hash tag # 
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i, file_name in enumerate(listFileNames):
			if (file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
				fileUuid = self.__generateTraceFile(file_name, 
				'', '', '', 'Uncategorized', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '', '', '', '')
				
				self.__generateTraceRelation(fileUuid, uuid, 'Connected_To', 
				'', '')
		return uuid


	def __generateTraceDevice(self, deviceMAC, deviceSN, deviceModel,
		deviceOS, deviceOSVersion, deviceManufacturer, deviceWiFi, deviceICCID,
		deviceIMSI, deviceIMEI, deviceBluetoothAddress):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:DeviceFacet",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:model":"' + deviceModel + '",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:serialNumber":"' + deviceSN + '"\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:MobileDeviceFacet",\n', \
			UFEDtoJSON.C_TAB*3 + '"uco-observable:IMEI":"' + deviceIMEI + '"\n', \
		
#	if properties are not provided, the related line is not written
#
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:bluetoothDeviceName":"NOT_PROVIDED",\n'
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:mockLocationsAllowed":"NOT_PROVIDED",\n'		
		#	line += UFEDtoJSON.C_TAB*2 + '"uco-observable:phoneActivationTime":\n'
		#line += UFEDtoJSON.C_TAB*3 + '{\n'
		#line += UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n'
		#line += UFEDtoJSON.C_TAB*3 + '"@value":"NOT_PROVIDED"\n'
		#line += UFEDtoJSON.C_TAB*3 + '},\n'
		
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:storageCapacityInBytes":{\n'
		#line += UFEDtoJSON.C_TAB*3 + '"@type": "xsd:long",\n'
		#line += UFEDtoJSON.C_TAB*3 + '"@value": "NOT_PROVIDED"\n'
		#line += UFEDtoJSON.C_TAB*2 + '},\n'

		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:clockSetting":"NOT_PROVIDED"\n'
			UFEDtoJSON.C_TAB*2 + '},\n' , \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:OperatingSystemFacet",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-core:name": "' + deviceOS + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:manufacturer":"' + deviceManufacturer + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:version":"' + deviceOSVersion + '"\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, nither observable:AndroidDevice nor observable:AppleDevice are
#	classes of the observable.ttl ontology
#
		#line += UFEDtoJSON.C_TAB*2 + '{\n'		
		#if deviceOS.lower() == 'android':
		#	line += UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:AndroidDevice",\n'
		#	line += UFEDtoJSON.C_TAB*2 + '"uco-observable:androidID": "NOT_PROVIDED",\n'
		#	line += UFEDtoJSON.C_TAB*2 + '"uco-observable:androidSerialNumber": "' + deviceSN + '",\n'
		#else:
		#	line += UFEDtoJSON.C_TAB*2 + '"@type":"AppleDevice",\n'
		#	line += UFEDtoJSON.C_TAB*2 + '"uco-observable:AppleDeviceID": "NOT_PROVIDED",\n'
		#	line += UFEDtoJSON.C_TAB*2 + '"uco-observable:AppleDevideSerialNumber": "' + deviceSN + '",\n'

		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:screenUnlockPattern":"NOT_PROVIDED"\n'
		#line += UFEDtoJSON.C_TAB*2 + '},\n'
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:BluetoothAddressFacet",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + deviceBluetoothAddress + '"\n', \
			UFEDtoJSON.C_TAB*2 + '},\n ', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:WifiAddressFacet",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + deviceWiFi + '"}\n', \
		
		#line += UFEDtoJSON.C_TAB*2 + '{\n'
		#line += UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:MobileAccount",\n '
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:MSISDN":"NOT_PROVIDED"\n'
		#line += UFEDtoJSON.C_TAB*2 + '}\n'
			UFEDtoJSON.C_TAB + ']\n', \
			'},\n'])
		self.FileOut.write(line)
		return uuid
	
	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, 
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):

		if EMAILidentifierFROM.strip() in self.EMAILaddressList:
			idx = self.EMAILaddressList.index(EMAILidentifierFROM.strip())
			idFROM = self.EMAILaccountIdList[idx]
		else:
			self.EMAILaddressList.append(EMAILidentifierFROM.strip())
			uuidEmail = self.__generateTraceEmailAccount(EMAILidentifierFROM.strip())
			self.EMAILaccountIdList.append(uuidEmail)
			idFROM = uuidEmail

		itemsTO = ''
		for i, email_identifier in enumerate(EMAILidentifiersTO):
			if email_identifier.strip() != '':
				if email_identifier.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier.strip())
					idTO = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idTO = '{"@id":"' + uuidEmail + '"}'
				itemsTO += itemsTO + idTO + ','
		
		# get rid of the last comma
		itemsTO = itemsTO[0:-1]

		itemsCC = ''
		for i, email_identifier_cc in enumerate(EMAILidentifiersCC):
			if email_identifier_cc.strip() != '':
				if email_identifier_cc.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier_cc.strip())
					idCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier_cc.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier_cc.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idCC = '{"@id":"' + uuidEmail + '"}'
				itemsCC += itemsCC + idCC + ','

		# get rid of the last comma
		itemsCC = itemsCC[0:-1]

		#	CASE 0.2/UCO 0.4 compliant, the right property is bcc
#		
		
		itemsBCC = ''
		for i, email_identifier_bcc in enumerate(EMAILidentifiersBCC):
			if email_identifier_bcc.strip() != '':
				if email_identifier_bcc.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier_bcc.strip())
					idBCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier_bcc.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier_bcc.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idBCC = '{"@id":"' + uuidEmail + '"}'
				itemsBCC += itemsBCC + idBCC + ','

		# get rid of the last comma
		itemsBCC = itemsBCC[0:-1]

		body = EMAILbody.replace('"', "")
		body = body.replace('\n', ' ')		
		#--- backslash and tab chars are not accepted in JSON value
		body = body.replace('\t', ' ')
		body = body.replace('\\', ' _BS_ ')

		subject = EMAILsubject.replace('"', "")
		subject = subject.replace('\n', ' ')
		subject = subject.replace('\\', ' _BS_ ')

		uuid = "kb:" + UFEDtoJSON.__createUUID()

		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)	

		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailMessageFacet",\n', \
#	CASE 0.2/UCO 0.4 compliant, it would be necessary to create a idref to the application
#
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:application":"' + EMAILsource + '",\n'
			UFEDtoJSON.C_TAB*2 + '"uco-observable:sentTime":\n', \
			UFEDtoJSON.C_TAB*3 + '{\n', \
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n', \
			UFEDtoJSON.C_TAB*3 + '"@value":"' + EMAILtimeStamp + '"\n', \
			UFEDtoJSON.C_TAB*3 + '},\n', \

#	CASE 0.2/UCO 0.4 compliant, the right property is from
#			
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isMimeEncoded":false,\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isMultipart":false,\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:from":{\n', \
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idFROM + '"\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is to
#		
			UFEDtoJSON.C_TAB*2 + '"uco-observable:to":[', \
			itemsTO + '],\n', \
#	CASE 0.2/UCO 0.4 compliant, the right property is cc
#		
			UFEDtoJSON.C_TAB*2 + '"uco-observable:cc":[', \
			itemsCC + '],\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:bcc":[', \
			itemsBCC + '],\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:body":"' + body + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:subject":"' + subject + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + EMAILstatus + '"\n', \
			UFEDtoJSON.C_TAB*2 + '} \n', \
			UFEDtoJSON.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line);
		self.__generateChainOfEvidence(EMAILid, uuid)

		for i, email_attachment in enumerate(EMAILattachmentsFilename):
			if email_attachment.strip() != '':
				fileUuid = self.__generateTraceFile(email_attachment, 
				'', '', '', 'Uncategorized', '', '', '', '',
  				'', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(fileUuid, uuid, 'Attached_To', 
				'', '')
		return uuid

	def __generateTraceEmailAccount(self, address):
		
		uuidAddress = self.__generateTraceEmailAddress(address)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:AccountFacet", \n', \

#	CASE 0.2/UCO 0.4 compliant, there is no property accountIssuer
#		
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIssuer": "' + \
		#	'' + '",\n'
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isActive":true,\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n', \
			UFEDtoJSON.C_TAB*2 + '},\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailAccountFacet",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:emailAddress":\n', \
			UFEDtoJSON.C_TAB*3 + '{"@id":"' + uuidAddress + '"}\n', \
			UFEDtoJSON.C_TAB*2 + '}\n', \
			UFEDtoJSON.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceEmailAddress(self, address):
		
		address = address.replace('"', "'")

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:EmailAddressFacet", \n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:addressValue":"' + address +'"\n', \
			UFEDtoJSON.C_TAB + '}\n', \
			UFEDtoJSON.C_TAB + '] \n', \
			'}, \n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEiNode, FILEiNodeTimeM, FILEgid, FILEuid, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude, FILEexifMake, FILEexifModel):		
		#print("original FILEpath:" + FILEpath)
		head, tail = os.path.split(FILEpath)
		tail = tail.replace("\\", "/")
		tail = tail.replace('"', "'")
		path = FILEpath.replace('\\', '/')
		path = path.replace('"', "'")
		dotPos = tail.find('.')
		sExt = tail[dotPos:]
		
		if FILEHashValue.upper() == 'N/A':
			FILEHashValue = UFEDtoJSON.C_HASH_V
		
#---	set a default value to avoid errors in the Tool Validator
#		
		if FILEHashValue.strip() == '':
				FILEHashValue = UFEDtoJSON.C_HASH_V

		if FILEhashType.strip() == '':
			FILEhashType = UFEDtoJSON.C_HASH_M

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = UFEDtoJSON.C_HASH_M
		
		if FILETag.upper() == '_NOT_PROVIDED_':
			FILETag = 'Uncategorized';			

		if  FILEsize.strip == '0':
			sizeFile = UFEDtoJSON.C_TAB*2 + '}\n'
		else:
			sizeFile = "".join([UFEDtoJSON.C_TAB*2 + '},\n' ,\
				UFEDtoJSON.C_TAB*2 + '{\n',\
				UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:ContentDataFacet",\n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:hash":[\n',\
				UFEDtoJSON.C_TAB*3 + '{\n',\
				UFEDtoJSON.C_TAB*3 + '"@type":"uco-types:Hash",\n',\
				UFEDtoJSON.C_TAB*3 + '"uco-types:hashMethod":\n',\
				UFEDtoJSON.C_TAB*4 + '{\n',\
				UFEDtoJSON.C_TAB*4 + '"@type": "uco-vocabulary:HashNameVocab",\n',\
				UFEDtoJSON.C_TAB*4 + '"@value": "' + FILEhashType + '"\n',\
				UFEDtoJSON.C_TAB*4 + '},\n',\
				UFEDtoJSON.C_TAB*3 + '"uco-types:hashValue":\n',\
				UFEDtoJSON.C_TAB*4 + '{\n',\
				UFEDtoJSON.C_TAB*4 + '"@type": "xsd:hexBinary",\n',\
				UFEDtoJSON.C_TAB*4 + '"@value":"' + FILEHashValue  + '"\n',\
				UFEDtoJSON.C_TAB*4 + '}\n',\
				UFEDtoJSON.C_TAB*3 + '}\n',\
				UFEDtoJSON.C_TAB*2 + '] \n',\
			#line += UFEDtoJSON.C_TAB*2 +  '"uco-observable:sizeInBytes":"256"\n'
				UFEDtoJSON.C_TAB*2 + '}\n'])



		uuid = "kb:" + UFEDtoJSON.__createUUID()

#--- Replace all not number occurrences with nothing
#		
		FILEsize = re.sub('[^0-9]','', FILEsize)
		if FILEsize.strip() == '':
			FILEsize = UFEDtoJSON.C_INT;


#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		the character "/" is not allowed
#		
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)	
		
		FILEiNodeTimeM = self.__cleanDate(FILEiNodeTimeM)

#---	these values are defined as xsd:integer
#		
		FILEiNode = FILEiNode.strip()

		if FILEiNode.strip() == '':
			FILEiNode = UFEDtoJSON.C_INT	
		
		if FILEiNode.find('0x') > - 1:
			FILEiNode = int(FILEiNode, 16)


		FILEuid = FILEuid.strip()

		if FILEuid.strip() == '':
			FILEuid = UFEDtoJSON.C_INT	

		if FILEuid.find('0x') > - 1:
			FILEuid = int(FILEuid, 16)

		

		FILEgid = FILEgid.strip()

		if FILEgid.strip() == '':
			FILEgid = UFEDtoJSON.C_INT

		if FILEgid.find('0x') > - 1:
			FILEgid = int(FILEgid, 16)

		localPath = FILElocalPath.replace("\\", "/")	 

		line_exif = ''
		if FILEexifLatitude.strip() != '':
			line_exif = "".join([',' + UFEDtoJSON.C_TAB*2 + '{\n' ,\
				UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:EXIFFacet",\n',\
				UFEDtoJSON.C_TAB*3 + '"uco-observable:exifData": {\n',\
				UFEDtoJSON.C_TAB*4 + '"@type": "uco-types:ControlledDictionary",\n',\
				UFEDtoJSON.C_TAB*4 + ' "uco-types:entry": [\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "Make",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifMake + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "Model",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifModel + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "LatitudeRef",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifLatitudeRef + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "Latitude",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifLatitude + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "LongitudeRef",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifLongitudeRef + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "Longitude",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifLongitude + '"\n',\
				UFEDtoJSON.C_TAB*5 + '},\n',\
				UFEDtoJSON.C_TAB*5 + '{\n',\
				UFEDtoJSON.C_TAB*6 + '"@type": "uco-types:ControlledDictionaryEntry",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:key": "Altitude",\n',\
				UFEDtoJSON.C_TAB*6 + '"uco-types:value": "' + FILEexifAltitude + '"\n',\
				UFEDtoJSON.C_TAB*5 + '}\n',\
				UFEDtoJSON.C_TAB*4 + ']\n',\
				UFEDtoJSON.C_TAB*3 + '}\n',\
				UFEDtoJSON.C_TAB*2 + '}\n'])

		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n', \
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject",\n', \
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:tag":["' + FILETag + '"],\n'	, \
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n', \
			UFEDtoJSON.C_TAB*2 + '{\n', \
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:FileFacet",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:fileName":"' + tail + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:filePath":"' + path + '",\n', \

#--- 	the property fileLocalPath is not included in the UCO observable.TTL
#			ontology yet
#			
			UFEDtoJSON.C_TAB*2 + '"uco-observable:fileLocalPath":"' + localPath + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:extension":"' + sExt + '",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:fileSystemType":"userdata (ExtX)",\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isDirectory":false,\n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:sizeInBytes": {\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"xsd:integer", \n',\
			UFEDtoJSON.C_TAB*2 + '"@value":"' + FILEsize + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-core:objectCreatedTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + FILEtimeC + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-core:objectModifiedTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + FILEtimeM + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-core:objectAccessedTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + FILEtimeA + '"\n',\
			UFEDtoJSON.C_TAB*3 + '}\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '{\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:ExtInodeFacet",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:extInodeID":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + str(FILEiNode) + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:extSGID":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + str(FILEgid) + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:extSUID":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + str(FILEuid) + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:extInodeChangeTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + FILEiNodeTimeM + '"\n',\
			UFEDtoJSON.C_TAB*3 + '}\n',\
			sizeFile , \
			line_exif , \
			UFEDtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line);
		return uuid


	def __generateTraceIdentity(self, name, familyName, birthDate):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
		birthDate = self.__cleanDate(birthDate)

		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-identity:Identity",\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			UFEDtoJSON.C_TAB*2 + '{\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-identity:SimpleNameFacet",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-identity:givenName":"' + name + '",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-identity:familyName":"' + familyName + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '{\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-identity:BirthInformationFacet",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-identity:birthdate":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + birthDate + '"\n',\
			UFEDtoJSON.C_TAB*2 + '}\n',\
			UFEDtoJSON.C_TAB + '}\n',\
			UFEDtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneAccount(self, Source, Name, PhoneNum):
		
		if Source == "":
			sourceLine= ''
		else:
			sourceLine += UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			UFEDtoJSON.C_TAB*2 + '{ \n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:AccountFacet", \n',\
			sourceLine,\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isActive":true,\n' ,\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n' ,\
			UFEDtoJSON.C_TAB*2 + '}, \n',\
			UFEDtoJSON.C_TAB*2 + '{ \n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:PhoneAccountFacet", \n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n',\
#	CASE 0.2/UCO 0.4 compliant, no 	uco-observable:name property in observable.ttl
#			
			UFEDtoJSON.C_TAB*2 + '"uco-core:name":"' + Name + '" \n', \
			UFEDtoJSON.C_TAB*2 + '} \n',\
			UFEDtoJSON.C_TAB + '] \n',\
			'}, \n'])
		self.FileOut.write(line);
		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = ''
		for i in range(n - 1):
			lineResult += UFEDtoJSON.C_TAB*3 + '{"@id":"' + listResult[i] + '"},';

		if n > 0:
			lineResult += '{"@id":"' + listResult[n - 1]  + '"}\n'
			lineResult += UFEDtoJSON.C_TAB*2 + ']\n'
			lineResult += UFEDtoJSON.C_TAB*2 + '}';


		uuid = "kb:" + UFEDtoJSON.__createUUID()
#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
		startTime = self.__cleanDate(startTime)
		endTime = self.__cleanDate(endTime)

		if location.strip() == '':
			location = UFEDtoJSON.C_LOCATION	

		uuidLocation = self.__generateTraceLocation(location)

		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB +  '"@type":"case-investigation:InvestigativeAction",\n',\
			UFEDtoJSON.C_TAB +  '"uco-core:name":"' + name + '",\n',\
			UFEDtoJSON.C_TAB + '"uco-core:description":"' + description + '",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:startTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:endTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + endTime + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			UFEDtoJSON.C_TAB*2 + '{\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-action:ActionReferencesFacet",\n' ,\
			UFEDtoJSON.C_TAB*2 + '"uco-action:instrument":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idInstrument + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:location":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@id":"' + uuidLocation + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:performer":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idPerformer + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:object":[\n',\
			UFEDtoJSON.C_TAB*3 + '{"@id":"' + idObject + '"}\n',\
			UFEDtoJSON.C_TAB*2 + '],\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-action:result":[\n',\
			lineResult,\
			UFEDtoJSON.C_TAB + ']\n',\
			'}' + endChar + '\n'])
		self.FileOut.write(line);
		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):

		nTime = 0
		if duration != "":
			aTime = duration.split(":")
			if len(aTime) == 3:
				if aTime[2].find('.') > -1:
					aTime[2] = aTime[2][0:aTime[2].find('.')]
				if aTime[2].find(',') > -1:
					aTime[2] = aTime[2][0:aTime[2].find(',')]

				nTime = int(aTime[0])*3600 + int(aTime[1])*60 + int(aTime[2])
			if len(aTime) == 2:
				nTime = int(aTime[0])*60 + int(aTime[1]) 
			if len(aTime) == 1:
				nTime = int(aTime[0]) 
		duration = str(nTime)
		duration = duration.lstrip('0')
		
		point = duration.find('.') 
		if point > - 1:
			duration = duration[0:point]
		
		if duration == "":
			duration = "0"

		if "Native" in self.appNameList: 
			idx = self.appNameList.index("Native")
			idAppName = self.appNameList[idx]
			idAppIdentity = self.appIDList[idx]
		else:
			idAppIdentity = self.__generateTraceAppName("Native")
			self.appNameList.append("Native")
			self.appIDList.append(idAppIdentity)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		startTime = self.__cleanDate(startTime)

		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			UFEDtoJSON.C_TAB*2 + '{ \n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:PhoneCallFacet", \n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:callType":"' + direction + '",\n ',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:startTime":\n',\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":"' + startTime + '"\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:application":{ \n', \
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idAppIdentity + '" \n', \
			UFEDtoJSON.C_TAB*2 + '}, \n', \
			UFEDtoJSON.C_TAB*2 + '"uco-observable:from":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idFROM + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:to":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@id":"' + idTO + '"\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:duration":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer",\n',\
			UFEDtoJSON.C_TAB*3 + '"@value":' + duration + '\n',\
			UFEDtoJSON.C_TAB*3 + '},\n',\
#	CASE 0.2/UCO 0.4 compliant no uco-observable:outcome property in Observable
#		
		#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:drafting:outcome":"' + outcome + '", \n'
			UFEDtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + status + '" \n',\
			UFEDtoJSON.C_TAB*2 + '}\n' ,\
			UFEDtoJSON.C_TAB + '] \n',\
			'}, \n'])
		self.FileOut.write(line);
		return uuid
	

	def __generateTracePhoneOwner(self, Source, Name, PhoneNum):
		
		if Source == "":
			lineSource = ''
		else:
			lineSource = UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIssuer":"' + Source + '", \n'
		
		self.phoneOwnerUuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' + self.phoneOwnerUuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
			UFEDtoJSON.C_TAB*2 + '{ \n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:AccountFacet", \n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:isActive":true,\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:accountIdentifier":" "\n' ,\
			UFEDtoJSON.C_TAB*2 + '}, \n',\
			UFEDtoJSON.C_TAB*2 + '{ \n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:PhoneAccountFacet", \n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:phoneNumber":"' + PhoneNum + '", \n',\
			lineSource,\
#	CASE 0.2/UCO 0.4 compliant	
#	
			UFEDtoJSON.C_TAB*2 + '"uco-core:name":"' + Name + '" \n', \
			UFEDtoJSON.C_TAB*2 + '} \n',\
			UFEDtoJSON.C_TAB + ']\n',\
			'}, \n'])
		self.FileOut.write(line);
		self.phoneNumberList.append(PhoneNum)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		
		#idx = 0
		n = len(idTracesList)
		lineTraces = ''
		
		for idx in range(n - 1):
			lineTraces += UFEDtoJSON.C_TAB*2  + '{"@id":"' + idTracesList[idx] + '"},\n'

		if n > 0:
			lineTraces += UFEDtoJSON.C_TAB*2  + '{"@id":"' + idTracesList[n - 1] + '"}\n'

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"case-investigation:ProvenanceRecord", \n',\
#---	createdTime is not part of the investigation.ttl ontology
#			2021-05-20, see 19th May email from Alex Nelson
#			
			#UFEDtoJSON.C_TAB*2 + '"case-investigation:createdTime":\n',\
			#UFEDtoJSON.C_TAB*3 + '{\n',\
			#UFEDtoJSON.C_TAB*3 + '"@type":"xsd:dateTime",\n',\
			#UFEDtoJSON.C_TAB*3 + '"@value":"' + creationTime + '"\n',\
			#UFEDtoJSON.C_TAB*3 + '},\n',\

#---	description is not part of the investigation.ttl ontology
#			2021-06-09 relying on the new Tool Validator version
#
#			UFEDtoJSON.C_TAB + '"case-investigation:description":"' + description + '",\n',\
			UFEDtoJSON.C_TAB + '"case-investigation:exhibitNumber":"' + exhibitNumber + '",\n',\
			UFEDtoJSON.C_TAB + '"uco-core:object":[\n',\
			lineTraces,\
			UFEDtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid


	def __generateTraceRelation(self, source, target, relation, table, offset):
		
		if not table == '':
			cleanOffset = offset.replace('@', '')
			lineTable = "".join([UFEDtoJSON.C_TAB + '"uco-core:isDirectional":true,\n',\
				UFEDtoJSON.C_TAB + '"uco-core:hasFacet": [\n',\
				UFEDtoJSON.C_TAB*2 + '{\n ',\
				UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:DataRangeFacet",\n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:rangeOffset": {\n',\
				UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer", \n',\
				UFEDtoJSON.C_TAB*3 + '"@value":"' + cleanOffset + '"\n',\
				UFEDtoJSON.C_TAB*2 + '},\n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:rangeSize": {\n',\
				UFEDtoJSON.C_TAB*3 + '"@type":"xsd:integer", \n',\
				UFEDtoJSON.C_TAB*3 + '"@value":"0"\n',\
				UFEDtoJSON.C_TAB*2 + '}\n',\
				#UFEDtoJSON.C_TAB*3 + '"uco-observable:rangeOffsetType":"',\
				#table + '"\n',\
				UFEDtoJSON.C_TAB*2 + '}\n ',\
				UFEDtoJSON.C_TAB + ']'])
		else:
			lineTable = UFEDtoJSON.C_TAB + '"uco-core:isDirectional":true\n'

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableRelationship",\n',\
			UFEDtoJSON.C_TAB + '"uco-core:source":{\n',\
			UFEDtoJSON.C_TAB*2 + '"@id":"' + source + '"\n',\
			UFEDtoJSON.C_TAB + '},\n',\
			UFEDtoJSON.C_TAB + '"uco-core:target":{\n' ,\
			UFEDtoJSON.C_TAB*2 + '"@id":"' + target + '"\n',\
			UFEDtoJSON.C_TAB + '},\n',\
			
			#CASE 0.4
			#UFEDtoJSON.C_TAB*2 + '"@type": "uco-vocabulary:CyberItemRelationshipVocab",\n',\
			#UFEDtoJSON.C_TAB*2 + '"@value":"'		+ relation + '"\n',\
			#UFEDtoJSON.C_TAB + '},\n',\
			#UFEDtoJSON.C_TAB + '"uco-core:kindOfRelationship":{' + '\n',\
			UFEDtoJSON.C_TAB + '"uco-core:kindOfRelationship":"' + relation + '",\n',\
			lineTable,\
			'},\n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceRole(self, role):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-role:Role",\n',\
			UFEDtoJSON.C_TAB + '"uco-core:name":"' + role + '"\n',\
			'},\n'])
		self.FileOut.write(line)
		return uuid

	def __generateTraceSms(self, SMSid, SMSstatus, SMStimeStamp, 
							SMSpartyRoles, SMSpartyIdentifiers, 
							SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource):		
		for i, sms_id in enumerate(SMSid):
			#print('SMSC=' + SMSsmsc[i])
			phoneUuidTo = ''
			phoneUuidFrom = ''
			for j, sms_party_identifier in enumerate(SMSpartyIdentifiers[i]):				
				if sms_party_identifier.strip() != '':
					if sms_party_identifier in self.phoneNumberList:						
						idx = self.phoneNumberList.index(sms_party_identifier)						
						userId = self.phoneNumberList[idx]
						phonePartyUuid = self.phoneUuidList[idx]
					else:
# see previous comment of the use of the mobileOperator variable
						self.phoneNumberList.append(sms_party_identifier)
						self.phoneNameList.append(SMSpartyNames[i][j])
						mobileOperator = ""
						phonePartyUuid = self.__generateTracePhoneAccount(mobileOperator, 
							SMSpartyNames[i][j], sms_party_identifier)	
						self.phoneUuidList.append(phonePartyUuid)
				
					phoneUuidTo = ''
	        		# Party with Role=TO can be more than one
					if SMSpartyRoles[i][j] == 'To':
						phoneUuidFrom = self.phoneOwnerUuid
						phoneUuidTo += '{"@id":"' + phonePartyUuid + '"}' + ','
					else:
						phoneUuidFrom = phonePartyUuid
						phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'
			
			phoneSmscUuid = ''
			if SMSsmsc[i].strip() != '':
				if SMSsmsc[i].strip() in self.phoneNumberList:						
					idx = self.phoneNumberList.index(SMSsmsc[i].strip())						
					userId = self.phoneNumberList[idx]
					phoneSmscUuid = self.phoneUuidList[idx]
				else:
					self.phoneNumberList.append(SMSsmsc[i].strip())
					self.phoneNameList.append('SMSC')
					mobileOperator = ""
					#print('in __generateTraceSms / SMSsmsc, num: ' + SMSsmsc[i].strip())
					phoneSmscUuid = self.__generateTracePhoneAccount(mobileOperator, 
						'SMSC', SMSsmsc[i].strip())	
					self.phoneUuidList.append(phoneSmscUuid)

			if SMSfolder[i] == 'Inbox':
				if phoneUuidFrom.strip() == '':
						phoneUuidFrom = phoneSmscUuid
			else:
				if phoneUuidTo.strip() == '':
						phoneUuidTo = phoneSmscUuid	

			if self.phoneOwnerUuid.strip() != '':
				if phoneUuidTo == self.phoneOwnerUuid:
					phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'	
				else:
					if phoneUuidTo != '':
						if phoneUuidTo[-1] == ',':
							phoneUuidTo = phoneUuidTo[0:-1]

			body = SMSbody[i].replace('\n', ' ')
			body = body.replace('"', "'")
			body = body.replace('\t', ' ')
			body = body.replace("\\'", "'")
			body = body.replace("\\", "")

			uuid = "kb:" + UFEDtoJSON.__createUUID()
#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#			the character "/" is not allowed
#		
			SMStimeStamp[i] = SMStimeStamp[i].replace("/", "-")
			SMStimeStamp[i] = SMStimeStamp[i].replace(' ', 'T', 1)			
			SMStimeStamp[i] = SMStimeStamp[i].replace('UTC', '')			

			line = "".join(['{ \n', \
				UFEDtoJSON.C_TAB + '"@id":"' + uuid + '", \n',\
				UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
				UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
				UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[ \n',\
				UFEDtoJSON.C_TAB*2 + '{ \n',\
				UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageFacet", \n' ,\
#	CASE 0.2/UCO 0.4 compliant,  uco-observable:application is always the native app 
#	installed on the mobile phone
# 
			#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:application":"' + SMSsource[i] + '", \n' 
			
#	CASE 0.2/UCO 0.4 compliant,  uco-observable:SMSMessage is a class, not clear its possible
# values
#
			#line += UFEDtoJSON.C_TAB*2 + '"uco-observable:SMSmessage":"true", \n'
				UFEDtoJSON.C_TAB*2 + '"uco-observable:messageText":"' + body + '", \n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:allocationStatus":"' + SMSstatus[i] + '", \n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:from":{\n',\
				UFEDtoJSON.C_TAB*3 + '"@id":"' + phoneUuidFrom + '"\n',\
				UFEDtoJSON.C_TAB*2 + '},\n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:to":[' + phoneUuidTo + '], \n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:sentTime":{\n',\
				UFEDtoJSON.C_TAB*3 + '"@type": "xsd:dateTime", \n' ,\
				UFEDtoJSON.C_TAB*3 + ' "@value": "' + SMStimeStamp[i] + '"\n',\
				UFEDtoJSON.C_TAB*3 + '} \n'	,\
				UFEDtoJSON.C_TAB*2 + '} \n',\
				UFEDtoJSON.C_TAB + '] \n',\
				'}, \n'])
			self.FileOut.write(line)
			self.__generateChainOfEvidence(sms_id, uuid)

	def __generateThreadMessages(self, chatTraceId, chatThread, chatIdAccountList):
		
		nChatThread = len(chatThread)
		lineThread  = ''
		for i in range(nChatThread - 1):
			lineThread += UFEDtoJSON.C_TAB*3 + '{\n'
			lineThread += UFEDtoJSON.C_TAB*4 + '"olo:index":"' + str(i + 1) + '",\n'
			lineThread += UFEDtoJSON.C_TAB*4 + '"olo:item": {\n'
			lineThread += UFEDtoJSON.C_TAB*5 + '"@id":"' + chatThread[i] + '"\n'
			lineThread += UFEDtoJSON.C_TAB*4 + '}\n'
			lineThread += UFEDtoJSON.C_TAB*3 + '},\n'

		nChatAccounts = len(chatIdAccountList)
		lineChatAccounts = ''		
		for i in range(nChatAccounts - 1):
			lineChatAccounts += UFEDtoJSON.C_TAB*3 + '{"@id":"' + chatIdAccountList[i] + '"},\n'

		if nChatAccounts > 0:
			lineChatAccounts += UFEDtoJSON.C_TAB*3  + '{"@id":"' + chatIdAccountList[nChatAccounts - 1] + '"}]\n' 

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
			UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
			UFEDtoJSON.C_TAB*2 + '{\n',\
			UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:MessageThreadFacet",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:displayName":"",\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:message":{\n',\
			UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:Message", \n',\
			UFEDtoJSON.C_TAB*3 + '"uco-observable:hasChanged":true,\n',\
			UFEDtoJSON.C_TAB*3 + '"olo:length":"' + str(len(chatThread)) + '",\n',\
			UFEDtoJSON.C_TAB*3 + '"olo:slot":[\n',\
			lineThread,\
			UFEDtoJSON.C_TAB*3 + '{\n',\
			UFEDtoJSON.C_TAB*4 + '"olo:index":"' + str(nChatThread) + '",\n',\
			UFEDtoJSON.C_TAB*4 + '"olo:item": {\n',\
			UFEDtoJSON.C_TAB*5 + '"@id":"' + chatThread[nChatThread - 1] + '"\n',\
			UFEDtoJSON.C_TAB*4 + '}\n',\
			UFEDtoJSON.C_TAB*3 + '}\n',\
			UFEDtoJSON.C_TAB*3 + ']\n',\
			UFEDtoJSON.C_TAB*2 + '},\n',\
			UFEDtoJSON.C_TAB*2 + '"uco-observable:participant":[\n',\
			lineChatAccounts,\
			UFEDtoJSON.C_TAB*2 + '}\n',\
			UFEDtoJSON.C_TAB + ']\n',\
			'},\n'])
		self.FileOut.write(line)
		#self.__generateChainOfEvidence(chatTraceId, uuid)
		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
			UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
			UFEDtoJSON.C_TAB + '"@type":"uco-tool:Tool", \n',\
			UFEDtoJSON.C_TAB + '"uco-core:name":"' + name + '",\n' ,\
			UFEDtoJSON.C_TAB + '"uco-tool:toolType":"' + type + '",\n',\
			UFEDtoJSON.C_TAB + '"uco-tool:creator":"' + vendor + '",\n',\
			UFEDtoJSON.C_TAB + '"uco-tool:version":"' + version + '"\n'])

		if len(confList) > 0:  
			line += line + ',\n'
			line += UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n'
			line += UFEDtoJSON.C_TAB*2 + '{\n'
			line += UFEDtoJSON.C_TAB*2 + '"@type":"uco-tool:ConfigurationSettingType",\n'
			line += UFEDtoJSON.C_TAB*2 + '"configurationSetting":[\n'
			n = len(confList) - 1
			for i in range(n):
				listItems = []
				listItems = confList[i].split('@');
				line += UFEDtoJSON.C_TAB*3 + '{\n'
				line += UFEDtoJSON.C_TAB*3 + '"@type":"uco-tool:ConfigurationSettingType",\n'
				line += UFEDtoJSON.C_TAB*3 + '"uco-tool:itemName":"' + listItems[0] + '",\n'
				line += UFEDtoJSON.C_TAB*3 + '"uco-tool:itemValue":"' + listItems[1] + '"\n'
				line += UFEDtoJSON.C_TAB*3 + '},\n' 
    
			listItems.clear()
			listItems += confList[n].split('@')
			line += UFEDtoJSON.C_TAB*2 + '{\n'
			line += UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:ConfigurationSettingFacet",\n'
			line += UFEDtoJSON.C_TAB*2 + '"uco-observable:itemName":"' + listItems[0] + '",\n' 
			line += UFEDtoJSON.C_TAB*2 + '"uco-observable:itemValue":"' + listItems[1] + '"\n'
			line += UFEDtoJSON.C_TAB*2 + '}\n'
			line += UFEDtoJSON.C_TAB*2 + ']\n'
			line += UFEDtoJSON.C_TAB + '}\n'
			line += UFEDtoJSON.C_TAB + ']\n'
			line += '}\n';
		else:
			line += '},\n';

		self.FileOut.write(line);
		return uuid

	def __generateTraceURL (self, URL_Value):
		
		URL_Value = URL_Value.strip()
		URL_Value = URL_Value.replace('"', ' ')
		URL_Value = URL_Value.replace('\n', '')
		startHttp = URL_Value.strip().find('http')
		
		if startHttp > - 1:
			URL_Value = URL_Value[startHttp:]

		if URL_Value in self.UrlList: 
					idx = self.UrlList.index(URL_Value)
					uuid = self.UrlIDList[idx]
		else:
			uuid = "kb:" + UFEDtoJSON.__createUUID()							
			self.UrlList.append(URL_Value)
			self.UrlIDList.append(uuid)
		
			line = "".join(['{ \n', \
				UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
				UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n',\
				UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n',\
				UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
				UFEDtoJSON.C_TAB*2 + '{\n',\
				UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:URLFacet", \n',\
				UFEDtoJSON.C_TAB*2 + '"uco-observable:fullValue":"' + URL_Value + '"\n',\
				UFEDtoJSON.C_TAB*2 + '}\n',\
				UFEDtoJSON.C_TAB + ']\n',\
				'},\n'])
			self.FileOut.write(line)
		
		return uuid

	def __generateTraceLocation (self, Location):
		
		Location = Location.strip()
		if Location in self.LocationList: 
					idx = self.LocationList.index(Location)
					uuid = self.LocationIDList[idx]
		else:
			uuid = "kb:" + UFEDtoJSON.__createUUID()							
			self.LocationList.append(Location)
			self.LocationIDList.append(uuid)
		
			line = "".join(['{ \n', \
				UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n',\
				UFEDtoJSON.C_TAB + '"@type":"uco-location:Location", \n',\
				UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n',\
				UFEDtoJSON.C_TAB*2 + '{\n',\
				UFEDtoJSON.C_TAB*2 + '"@type":"uco-location:SimpleAddressFacet", \n',\
				UFEDtoJSON.C_TAB*2 + '"uco-location:locality":"' + Location + '"\n',\
				UFEDtoJSON.C_TAB*2 + '}\n',\
				UFEDtoJSON.C_TAB + ']\n',\
				'},\n'])
			self.FileOut.write(line)
		
		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited):

		for i, web_page_id in enumerate(WEB_PAGEid):
			uuid = "kb:" + UFEDtoJSON.__createUUID()
			
			WEB_PAGElastVisited[i] = self.__cleanDate(WEB_PAGElastVisited[i])

			line = '\n{ \n'
			line += UFEDtoJSON.C_TAB + '"@id":"' +  uuid + '", \n'
			line += UFEDtoJSON.C_TAB + '"@type":"uco-observable:ObservableObject", \n'
			line += UFEDtoJSON.C_TAB + '"uco-observable:hasChanged":true,\n'
			line += UFEDtoJSON.C_TAB + '"uco-core:hasFacet":[\n'
			line += UFEDtoJSON.C_TAB*2 + '{\n'
			line += UFEDtoJSON.C_TAB*2 + '"@type":"uco-observable:URLHistoryFacet", \n'
			line += UFEDtoJSON.C_TAB*2 + '"uco-observable:browserInformation":{\n' 

			if WEB_PAGEsource[i].strip() in self.appNameList: 
				idx = self.appNameList.index(WEB_PAGEsource[i].strip())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(WEB_PAGEsource[i].strip())
				self.appNameList.append(WEB_PAGEsource[i].strip())
				self.appIDList.append(idAppIdentity)

			line += UFEDtoJSON.C_TAB*3 + '"@id":"' + idAppIdentity + '"\n'
			line += UFEDtoJSON.C_TAB*2 + '},\n'

			#line += WEB_PAGEsource[i] + '", \n'
			line += UFEDtoJSON.C_TAB*2 + '"uco-observable:urlHistoryEntry": [\n'
			line += UFEDtoJSON.C_TAB*2 + '{\n'
			line += UFEDtoJSON.C_TAB*3 + '"@type":"uco-observable:URLHistoryEntry",\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:firstVisit":\n'
			line += UFEDtoJSON.C_TAB*4 + '{\n'
			line += UFEDtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += UFEDtoJSON.C_TAB*4 + '"@value":"1900-01-01T08:00:00"\n'
			line += UFEDtoJSON.C_TAB*4 + '},\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:lastVisit":\n'
			line += UFEDtoJSON.C_TAB*4 + '{\n'
			line += UFEDtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += UFEDtoJSON.C_TAB*4 + '"@value":"' + WEB_PAGElastVisited[i] + '"\n'
			line += UFEDtoJSON.C_TAB*4 + '},\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:expirationTime":\n'
			line += UFEDtoJSON.C_TAB*4 + '{\n'
			line += UFEDtoJSON.C_TAB*4 + '"@type":"xsd:dateTime",\n'
			line += UFEDtoJSON.C_TAB*4 + '"@value":"1900-01-01T08:00:00"\n'
			line += UFEDtoJSON.C_TAB*4 + '},\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:userProfile":"",\n'
			uuidUrl = self.__generateTraceURL(WEB_PAGEurl[i])
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:url":{\n' 
			line += UFEDtoJSON.C_TAB*4 + '"@id":"' + uuidUrl + '"\n'
			line += UFEDtoJSON.C_TAB*3 + '},\n'
#---	Referer URL is not present in the XML report, so it will be ignored
#			
			#uuidUrl = self.__generateTraceURL(UFEDtoJSON.C_REF_URL)
			#line += UFEDtoJSON.C_TAB*3 + '"uco-observable:referrerUrl":{\n'			
			#line += UFEDtoJSON.C_TAB*4 + '"@id":"' + uuidUrl + '"\n'
			#line += UFEDtoJSON.C_TAB*3 + '},\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:pageTitle":"' 
			title = WEB_PAGEtitle[i].replace('"', '')
			line += title + '",\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:visitCount":' 
			if WEB_PAGEvisitCount[i].strip() == '':
				line += '0,\n' 
			else:
				line += WEB_PAGEvisitCount[i] + ',\n' 
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:manuallyEnteredCount":{\n'
			line += UFEDtoJSON.C_TAB*4 + '"@type":"xsd:nonNegativeInteger",\n'
			line += UFEDtoJSON.C_TAB*4 + '"@value":"0"\n'
			line += UFEDtoJSON.C_TAB*4 + '},\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:keywordSearchTerm":"NULL",\n'
			line += UFEDtoJSON.C_TAB*3 + '"uco-observable:allocationStatus":"' 
			line += WEB_PAGEstatus[i] + '"\n'			
			line += UFEDtoJSON.C_TAB*3 + '}\n'
			line += UFEDtoJSON.C_TAB*2 + ']\n'  						
			line += UFEDtoJSON.C_TAB + '}\n'  					
			line += UFEDtoJSON.C_TAB + ']\n'  						
			line += '},\n'  						
			self.FileOut.write(line);
			
			endChar = ','
#---	last web page item, endChar is not "," (default) but " "
#			
			if i == len(WEB_PAGEid) - 1:
				endChar	= ' '

			self.__generateChainOfEvidence(web_page_id, uuid, endChar)

#---	it is not used anymore, every time the field Source is extracted
#		an uco-observable:Application item is created
#			
	def storeUserAccount(self, U_ACCOUNTsource, U_ACCOUNTname,
			U_ACCOUNTusername):
		for i, u_account_source in enumerate(U_ACCOUNTsource):
			idAppName = self.__generateTraceAppName(u_account_source)
			self.appNameList.append(u_account_source)
			self.appIDList.append(idAppName)


	def writeExtraInfo(self, EXTRA_INFOdictPath, EXTRA_INFOdictSize, EXTRA_INFOdictTableName, 
				EXTRA_INFOdictOffset, EXTRA_INFOdictNodeInfoId):
		self.EXTRA_INFOdictPath = EXTRA_INFOdictPath
		self.EXTRA_INFOdictSize = EXTRA_INFOdictSize
		self.EXTRA_INFOdictTableName = EXTRA_INFOdictTableName
		self.EXTRA_INFOdictOffset = EXTRA_INFOdictOffset
		self.EXTRA_INFOdictNodeInfoId = EXTRA_INFOdictNodeInfoId		

	def writePhoneAccountFromContacts(self, CONTACTname, CONTACTphoneNums):
		for i, contact_name in enumerate(CONTACTname):
			for j, contact_phone_num in enumerate(CONTACTphoneNums[i]):
				if contact_phone_num in self.phoneNumberList:					
					pass
				else:
					self.phoneNumberList.append(contact_phone_num)
					self.phoneNameList.append(contact_name)
					mobileOperator = ""
					uuid = self.__generateTracePhoneAccount(mobileOperator, 
						contact_name, contact_phone_num)
					self.phoneUuidList.append(uuid)

	def writeHeader(self):
		self.__generateHeader()

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber):
		self.phoneOwnerNumber = phoneOwnerNumber
#	see previous comment of the use of the mobileOperator variable
#	the mobileOwnerName is not available in the XML report		
		mobileOperator = ""
		mobileOwnerName = ""
		self.__generateTracePhoneOwner(mobileOperator, mobileOwnerName, phoneOwnerNumber)

	def writeFiles(self, FILEid, FILEpath, FILEsize, FILEmd5, FILETag, 
					FILEtimeCreate, FILEtimeModify, FILEtimeAccess, FILElocalPath, 
                    FILEiNodeNumber, FILEiNodeTimeM, FILEownerGID, FILEownerUID,
                    FILEexifLatitudeRef, FILEexifLatitude, FILEexifLongitudeRef,
                    FILEexifLongitude, FILEexifAltitude, FILEexifMake, FILEexifModel):
			self.FILEid = FILEid
			for i, file_id in enumerate(FILEid):					
				uuid = self.__generateTraceFile(FILEpath[i], FILEsize[i], 
					'MD5', FILEmd5[i],	FILETag[i], FILEtimeCreate[i], FILEtimeModify[i], 
					FILEtimeAccess[i], FILElocalPath[i], FILEiNodeNumber[i], FILEiNodeTimeM[i],
					FILEownerGID[i], FILEownerUID[i], FILEexifLatitudeRef[i], 
					FILEexifLatitude[i], FILEexifLongitudeRef[i], FILEexifLongitude[i], 
					FILEexifAltitude[i], FILEexifMake[i], FILEexifModel[i])

				self.FILEuuid[file_id] = uuid
				self.FILEpath[file_id] = FILEpath[i]

	def writeChat(self, CHATid, CHATstatus, CHATsource, CHATpartyIdentifiers, CHATpartyNames, 
                CHATmsgIdentifiersFrom, CHATmsgNamesFrom, CHATmsgIdentifiersTo, 
                CHATmsgNamesTo, CHATmsgBodies, CHATmsgStatuses, CHATmsgOutcomes,
                CHATmsgTimeStamps, CHATmsgAttachmentFilenames, CHATmsgAttachmentUrls):		
		
		for i, chat_id in enumerate(CHATid):			
			if CHATsource[i].strip().lower() in self.appNameList: 
				idx = self.appNameList.index(CHATsource[i].strip().lower())
				idAppName = self.appNameList[idx]
				idAppIdentity = self.appIDList[idx]
			else:
				idAppIdentity = self.__generateTraceAppName(CHATsource[i].strip().lower())
				self.appNameList.append(CHATsource[i].strip().lower())
				self.appIDList.append(idAppIdentity)
			
			CHATidAccountList = []
			for j, chat_party_id in enumerate(CHATpartyIdentifiers[i]):	
				if chat_party_id.strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(chat_party_id.strip())
					CHATidAccountList.append(self.CHATaccountIdList[idx])
				else:
					self.CHATparticipantsNameList.append(CHATpartyNames[i][j].strip())
					idChatAccount = self.__generateTraceChatAccount(CHATsource[i].strip(),
						chat_party_id.strip(), CHATpartyNames[i][j].strip(),
						idAppIdentity)
					self.CHATparticipantsIdList.append(chat_party_id.strip())
					self.CHATaccountIdList.append(idChatAccount)
					CHATidAccountList.append(idChatAccount)

			appSource = CHATsource[i].strip().lower()
#---	if the Source is whatsapp, then the owner's whatsapp account must be part of 
#		the participants of the Chat
#			
			if appSource == 'whatsapp':
				if 'whatsapp' not in self.appNameList:
					idApp = self.__generateTraceAppName('whatsapp')
					self.appNameList.append('whatsapp')
					self.appIDList.append(idApp)					

				idx = self.appNameList.index('whatsapp')
				idAppWhatsApp = self.appIDList[idx]
				idPhoneOwner = self.phoneOwnerNumber + '@s.whatsapp.net'			
				if idPhoneOwner in self.CHATparticipantsIdList:
					pass
				else:
					self.CHATparticipantsNameList.append('PHONE_OWNER_NAME')
					idChatAccount = self.__generateTraceChatAccount('WhatsApp',
					idPhoneOwner, 'PHONE_OWNER_NAME', idAppWhatsApp)
					self.CHATparticipantsIdList.append(idPhoneOwner)
					self.CHATaccountIdList.append(idChatAccount)

#---	the owner's phone num must be always part of the participants Chat account
#					
				idx = self.CHATparticipantsIdList.index(idPhoneOwner)
				chatAccountPhoneOwner = self.CHATaccountIdList[idx]
				if chatAccountPhoneOwner in CHATidAccountList:
					pass
				else:
					CHATidAccountList.append(chatAccountPhoneOwner)
			
			CHATthread = []

#---	CHATmsgBodies[i] is the list of the messages of the same thread, the j index
#			iterates over all these messages
#			
			for j, chat_msg_body in enumerate(CHATmsgBodies[i]):	

#---	IdentifiersTo may contain more than one ID, separated by ###. This occurs
#		when a message is sent to a group and more than one recipient is involved
#				
				CHATmsgTo = CHATmsgIdentifiersTo[i][j].split('###')	

#---	If IdentifiersTo is empty, there is only a recipient: the phone owner number								
#				
				CHATmsgFrom = CHATmsgIdentifiersFrom[i][j].strip() 

#---	If Identifiers TO is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party
#				
				
				if CHATmsgTo[0].strip() == '':
					CHATmsgTo[0] = self.phoneOwnerNumber + '@s.whatsapp.net'
					direction = 'Incoming'
				else:			
					direction = 'Outgoing'
				
#---	if Identifiers FROM is empty, the array CHATpartyIdentifiers must
#		be iterated to find the right Party
#									
				if CHATmsgFrom == '':
					CHATmsgFrom = self.phoneOwnerNumber + '@s.whatsapp.net'

				chatUuid = self.__generateTraceChat(chat_msg_body, idAppIdentity, 
					CHATmsgTimeStamps[i][j], CHATmsgFrom, 
					CHATmsgTo, CHATmsgStatuses[i][j], CHATmsgOutcomes[i][j],
					direction, CHATmsgAttachmentFilenames[i][j], 
					CHATmsgAttachmentUrls[i][j])
				CHATthread.append(chatUuid)
				if CHATmsgAttachmentFilenames[i][j].strip() != '':
					#print("chat n." + str(i) + ', msg n.' + str(j) + ', attachment: ' + 
					#CHATmsgAttachmentFilenames[i][j])
					CHATattachmentFiles = CHATmsgAttachmentFilenames[i][j].split('###')
					for idx, chat_attachment_file in enumerate(CHATattachmentFiles):
						for key in self.FILEpath:						
							if self.FILEpath[key].find(chat_attachment_file) > - 1:
								self.__generateTraceRelation(self.FILEuuid[key], 
									chatUuid, 'Attached_To', '', '');
								break			

#---	if there are not messages for this Chat or no ChatAccount has been generated, 
#		the ThreadMessage is not generated. Moreover the Chain of evidence is built 
#		upon the ThreadUuid
#			
			if (len(CHATthread) == 0) or (len(CHATidAccountList) == 0):
				pass
			else:
				uuidThread = self.__generateThreadMessages(chat_id, CHATthread, 
								CHATidAccountList)
				self.__generateChainOfEvidence(chat_id, uuidThread)

	def writeEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
                EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename):
		for i, email_id in enumerate(EMAILid):
			self.__generateTraceEmail(email_id, EMAILstatus[i], EMAILsource[i],
				EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited):
		self.__generateTraceWebPages(WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited)

	def writeSms(self, SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles,
					SMSpartyIdentifiers, SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource):
		self.__generateTraceSms(SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles, 
					SMSpartyIdentifiers, SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource)

	def writeContextUfed(self, ufedVersionText, deviceReportCreateTime,
		deviceExtractionStartTime, deviceExtractionEndTime, examinerNameText,
		deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
		deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
		deviceMacAddressText, deviceIccidText, deviceImsiText, 
		deviceImeiText, imagePath, imageSize, 
		imageMetadataHashSHA, imageMetadataHashMD5):

		self.___generateContextUfed(ufedVersionText, deviceReportCreateTime,
			deviceExtractionStartTime, deviceExtractionEndTime, examinerNameText, 
			deviceBluetoothAddressText, deviceIdText, devicePhoneModelText, 
			deviceOsTypeText, deviceOsVersionText, devicePhoneVendorText, 
			deviceMacAddressText, deviceIccidText, deviceImsiText, 
			deviceImeiText, imagePath, imageSize, 
			imageMetadataHashSHA, imageMetadataHashMD5)


