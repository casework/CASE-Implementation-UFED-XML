#---	class UFEDtoJSON.py

import uuid
import os
import re
import json

class UFEDtoJSON:
	'''
	Represents all attributes and methods to represent Traces in CASE ontology, starting from data
	extracted from XML reports generated by UFED-PA forensic tool
	'''
	TAB = '\t'

# default value for string value not provided
#
	NP = ''  				

# default value for integer value not provided
#
	INT = '0'				

# default value for date value not provided
#
	DATE = '1900-01-01T08:00:00'				

# default value for Hash Method value not provided
#
	HASH_M = 'MD5' 	

# default value for Hash Method value not provided
#
	HASH_V = '1' * 76 	

# default value for the property referrerUrl of the URLHistoryFacet class
#
	REF_URL = 'http:www.empty.com/referrer_url'

# default value for the location where a forensic action was carried out
#
	LOC = 'Unknown location'


	def __init__(self, fileOut, appName, appUserName, appUserAccount):
		self.FileOut = fileOut
		self.phoneNumberList = []
		self.phoneNameList = []
		self.phoneUuidList = []
		
		self.appNameList = []
		self.appAccountUsernameList = []
		self.appAccountNameList = []
		self.appIDList = []
		self.accountName = []
		self.uuidaccountName = []

		self.CHATparticipantsNameList = []
		self.CHATparticipantsIdList = []
		self.CHATaccountIdList = []

		self.EMAILaccountIdList = []
		self.EMAILaddressList = []
		self.phoneOwnerNumber = ''
		self.phoneOwnerUuid = ''
		self.FILEuuid = {}
		self.FILEpath = {}
		self.FILEid = []

		self.EXTRA_INFOdictPath = {}
		self.EXTRA_INFOdictSize = {}
		self.EXTRA_INFOdictTableName = {}
		self.EXTRA_INFOdictOffset = {}
		self.EXTRA_INFOdictNodeInfoId = {}

		self.U_ACCOUNTapp = appName
		self.U_ACCOUNTappUserName = appUserName
		self.U_ACCOUNTappUserAccount = appUserAccount

		self.DEVICE_uuid = ''

		self.UrlList = {}

		self.LocationList = []
		self.LocationIDList = []

		self.CELL_TOWER_gsm ={}
		self.CELL_TOWER_cdma ={}

		self.WIRELESS_NET_ACCESS ={}

		self.LOCATION_lat_long_coordinate = {}
		self.SEARCHED_ITEMvalue_date = []


		self.SYS_MSG_ID = ''

		
	# static methods do not receive class or instance arguments
	# and usually operate on data that is not instance or class-specific
	@staticmethod
	def __createUUID():
		'''	
		Traces in CASE have a unique identification number, based on Globally Unique Identifier.  
		Each time a Trace is generated this static method in invoked, it doen't depends on any object
		'''
		return str(uuid.uuid4())

	def __checkAppName(self, name):
		if name in self.appNameList: 
			idx = self.appNameList.index(name)
			uuidAppIdentity = self.appIDList[idx]
		else:
			uuidAppIdentity = self.__generateTraceAppName(name)
			self.appNameList.append(name)
			self.appIDList.append(uuidAppIdentity)
		
		return uuidAppIdentity

	def __checkAccountName(self, account, name, uuidApp):
		self.accountName = []
		self.uuidaccountName = []
		id = account + '###' + name
		if id not in self.accountName: 
			uuid = self.__generateTraceApplicationAccount(account, name, uuidApp)
			self.accountName.append(id)
			self.uuidaccountName.append(uuid)

	def __checkGeoCoordinates(self, latitude, longitude, elevation, category):
		latitude = latitude.strip()
		longitude = longitude.strip()
		
		uuidLocation = ''
		if latitude != '' and longitude != '':
			id_geo_loc = latitude + '@' + longitude
			if id_geo_loc in self.LOCATION_lat_long_coordinate.keys():
				uuidLocation = self.LOCATION_lat_long_coordinate[id_geo_loc]
			else:
				uuidLocation = self.__generateTraceLocationCoordinate(latitude, 
					longitude, elevation, category)
				self.LOCATION_lat_long_coordinate[id_geo_loc] = uuidLocation

		return uuidLocation

	def __checkSearchedItems(self, value):
		
		itemFound = False
		if value not in self.SEARCHED_ITEMvalue_date:			
			self.SEARCHED_ITEMvalue_date.append(value)
			itemFound = True

		return itemFound

	def __checkUrlAddress(self, address):
		
		if address in self.UrlList.keys(): 
			uuid = self.UrlList.get(address)
		else:
			uuid = self.__generateTraceURLFullValue(address)
			self.UrlList[address] = uuid
	
		return uuid

	def __checkChatParticipant(self, chat_id, chat_name, chat_source, id_app):
		if chat_id.strip() in self.CHATparticipantsIdList: 
			idx = self.CHATparticipantsIdList.index(chat_id.strip())
			idChatAccount = self.CHATaccountIdList[idx]
		else:
			self.CHATparticipantsNameList.append(chat_name.strip())
			idChatAccount = self.__generateTraceApplicationAccount(chat_id.strip(), 
				chat_name.strip(), id_app)
			self.CHATparticipantsIdList.append(chat_id.strip())
			self.CHATaccountIdList.append(idChatAccount)
		
		return idChatAccount
	
	def __checkPhoneNumber(self, contact_phone_num, contact_name):
		if contact_phone_num not in self.phoneNumberList:					
			self.phoneNumberList.append(contact_phone_num)
			self.phoneNameList.append(contact_name)
			mobileOperator = ""
			uuid = self.__generateTracePhoneAccount(mobileOperator, 
				contact_name, contact_phone_num)
			self.phoneUuidList.append(uuid)

	def __cleanDate(self, originalDate):
		aMonths = {
			'Jan': '01',
			'Feb': '02',
			'Mar': '03',
			'Apr': '04',
			'May': '05',
			'Jun': '06',
			'Jul': '07',
			'Aug': '08',
			'Sep': '09',
			'Oct': '10',
			'Nov': '11',
			'Dec': '12'
		}

		originalDate = originalDate.strip()
#---	the xsd:dateTime must have the format YYYY-MM-DDTHH:MM:SS (UTCxxx)
#		

		if 	originalDate == '':
			return UFEDtoJSON.DATE

		for k,v in aMonths.items():
			if originalDate.find(k) > -1:
				originalDate = originalDate.replace(k, v)
				break

		originalDate = originalDate.replace("/", "-")
		originalDate = originalDate.replace("(", "-")
		originalDate = originalDate.replace(")", "-")
		originalDate = originalDate.replace(' ', 'T', 1)
		originalDate = originalDate.replace('UTC', '')
		originalDate = originalDate.replace('AM', '')
		originalDate = originalDate.replace('PM', '')
		if re.search('^[0-9]{4}', originalDate):
			pass
		else:
			originalDate = re.sub('-([0-9][0-9])T', '-20\g<1>T', originalDate)
			originalDate = str(originalDate[6:10]) + originalDate[2:6] + originalDate[0:2] + \
				originalDate[10:] 

		startTZ = originalDate.find("+")
		if startTZ > -1:
			originalDate = originalDate[:startTZ]

		firstChars = originalDate[:10]
		firstChars = firstChars.replace(".", "-")
		originalDate = firstChars + originalDate[10:]

		originalDate = originalDate.strip()

		if originalDate[-1] == '-':
			originalDate = originalDate[0:-1]

		originalDate = originalDate.replace('.000', '')
		originalDate = originalDate.replace('.', ':')

		if re.search('T\d{2}\.', originalDate):
			originalDate = originalDate.replace('.', ':')

		if re.search('(\d{2}:\d{2}:\d{2})$', originalDate):
			pass
		else:
			originalDate = re.sub('(\d{2}:\d{2})$', '\g<1>:00', originalDate)

		if re.search('T(\d):', originalDate):
			originalDate = re.sub('T(\d):', 'T0\g<1>:', originalDate)

		if re.search(':(\d):', originalDate):
			originalDate = re.sub(':(\d):', ':0\g<1>:', originalDate)

		if re.search(':(\d)$', originalDate):
			originalDate = re.sub(':(\d)$', ':0\g<1>', originalDate)

		if re.search('T\d{2}:\d{2}:\d{2}(.+)$', originalDate):
			originalDate = re.sub('(T\d{2}:\d{2}:\d{2})(.+)$', '\g<1>', originalDate)


		return originalDate.strip()	

	def __cleanJSONtext(self, originalText):
		new_text = originalText.strip()
		if new_text == '':
			return ''
		else:
			new_text = new_text.replace('"', "").replace('\n', '').replace('\r', '')
			new_text = new_text.replace('\t', " ").replace("\\'", "'").replace("\\", "")
			return new_text

	def __generateContextUfed(self, ufedVersion, deviceReportCreateTime,
			deviceExtractionStartTime, deviceExtractionEndTime, examinerName, 
			imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		# generate Trace/Tool for the Acquisition and Extraction Actions
		idTool = self.__generateTraceTool('UFED PA', 'Acquisition', 
			'Cellebrite', ufedVersion, []);
		
		# generate Trace/Identity for the Performer, D.F. Expert, of the Actions
		idIdentity = self.__generateTraceIdentity(examinerName, '', '')
		
		# generate Trace/Role for the Performer, D.F. Expert, of the Actions
		idRole = self.__generateTraceRole('Digital Forensic Expert')
		
		# generate Trace/Relation between the above Role and the Identity traces
		self.__generateTraceRelation(idIdentity, idRole, 'has_role', '', '', '', '');		
		
#---	the XML report contains the attribute DeviceInfoExtractionStartDateTime 
#			that is the Acquisition Start Date and similarly for the Acquisition
#			End Date, The CreationReportDate is the Start and the End of the Extraction 
#			Forensic Action
#


#---	generate Trace/Provenance_Record for the mobile device
#
		idDeviceList = []
		idDeviceList.append(self.DEVICE_uuid)
		idProvenanceDevice = self.__generateTraceProvencance(idDeviceList, 'Mobile device', 
			'', deviceExtractionStartTime) 
		
#---	generate Trace/File for each file extracted by the Acuisition action
#			idFileList contains the uuid of these files and it is used for
#			creating the Provenance_Record of the Result/Output of the Acquisition 
# 		action. 
#			2021-08-02: actually the XML report doesn't include the Acquisition info
#		
		idFilesAcquisition = []
		for i, img_path in enumerate(imagePath):
			if imageMetadataHashSHA[i].strip() == '':
				idFileAcquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'MD5', imageMetadataHashMD5[i], 'Uncategorized', '', '', '', '',
				'', '', '', '', '', '', '', '', '', '', '')  
				 
			else:
				idFileAcquisition = self.__generateTraceFile(img_path, 
				imageSize[i], 'SHA256', imageMetadataHashSHA[i], 'Uncategorized', 
				'', '', '', '', '', '', '', '', '', '', '', '', '', '', '') 				
			
			idFilesAcquisition.append(idFileAcquisition)  	
		

		idProvenanceAcquisitionFiles = \
			self.__generateTraceProvencance(idFilesAcquisition, 
        	'Acquisition files', '', deviceExtractionStartTime)

		idProvenanceAcquisitionFilesList = []
		idProvenanceAcquisitionFilesList.append(idProvenanceAcquisitionFiles)
		
		idProvencanceAcquisitionAction = \
		self.__generateTraceInvestigativeAction('acquisition', 
			'Forensic mobile device acquisition', deviceExtractionStartTime, 
			deviceExtractionEndTime, idTool, '', 
			idIdentity, idProvenanceDevice, idProvenanceAcquisitionFilesList, ',');

		idFilesExtraction = []
		for uuidFile in self.FILEuuid.values(): 
			idFilesExtraction.append(uuidFile)

		idProvenanceExtractionFiles = \
		self.__generateTraceProvencance(idFilesExtraction, 'Extraction',
			'', deviceReportCreateTime);
        
		idProvenanceExtractionFilesList = []
		idProvenanceExtractionFilesList.append(idProvenanceExtractionFiles)
		self.__generateTraceInvestigativeAction('extraction', 
			'Forensic mobile device extraction', deviceReportCreateTime,
			deviceReportCreateTime, idTool, '', idIdentity,
			idProvenanceAcquisitionFiles, idProvenanceExtractionFilesList, '');

	def __generateChainOfEvidence(self, IdTrace, uuidTrace, endChar=','):
#---	Search traceId in EXTRA_INFOdictNodeInfo a dictionary whose keys are the id
#			that represents the link between a Trace and its file(s)
#		
		table = self.EXTRA_INFOdictTableName.get(IdTrace, '_?TABLE')
		offset = self.EXTRA_INFOdictOffset.get(IdTrace, '_?OFFSET')

#---	This is the case where the infoNode sub element of extraInfo contains the id 
#			reference to the file. More then one infoNode can exist, the value of the key 
#			contains the id file separated by @@
#		
		if self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '').strip() == '':
			path = self.EXTRA_INFOdictPath.get(IdTrace, '_?PATH')
			size = self.EXTRA_INFOdictSize.get(IdTrace, '_?SIZE')
			if path != '_?PATH':
				uuidFile = self.__generateTraceFile(path, size, '', 
						'', 'Uncategorized', '', '', '', '', '', 
						'', '', '', '', '', '', '', '', '', '')

				self.FILEuuid[IdTrace] = uuidFile
				self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
					table, offset, '', '');
		else:
			nodeInfoIdList = self.EXTRA_INFOdictNodeInfoId.get(IdTrace, '@@@').split('@@@')
			for node in nodeInfoIdList:
				if node.strip() != '': 
					if node in self.FILEid: 
						#idFile = self.FILEid.index(node)
						#uuid = FILEuuid.get(idFile, '_?UUID')
						uuidFile = self.FILEuuid.get(node, '_?UUID')
						self.__generateTraceRelation(uuidTrace, uuidFile, 'Contained_Within', 
							table, offset, '', '');
					else:
						print ('nodeInfo ' + node + ' not found')		

	def __generateHeader(self):
		uuid = UFEDtoJSON.__createUUID()
		line = "".join(['{ \n', \
				UFEDtoJSON.TAB + '"@context": { \n', \
				UFEDtoJSON.TAB*2 + '"@vocabulary":"http://caseontology.org/core#", \n', \
				UFEDtoJSON.TAB*2 + '"not-in-ontology":"https://not-in/ontology#", \n', \
				UFEDtoJSON.TAB*2 + '"draft":"http://example.org/draft#", \n', \
				UFEDtoJSON.TAB*2 + '"case-investigation":"https://ontology.caseontology.org/case/investigation/", \n', \
				UFEDtoJSON.TAB*2 + '"rdf":"http://www.w3.org/1999/02/22-rdf-syntax-ns#", \n', \
				UFEDtoJSON.TAB*2 + '"rdfs":"http://www.w3.org/2000/01/rdf-schema#", \n', \
				UFEDtoJSON.TAB*2 + '"uco-action":"https://ontology.unifiedcyberontology.org/uco/action/", \n', \
				UFEDtoJSON.TAB*2 + '"uco-core":"https://ontology.unifiedcyberontology.org/uco/core/", \n', \
				UFEDtoJSON.TAB*2 + '"uco-identity":"https://ontology.unifiedcyberontology.org/uco/identity/",\n', \
				UFEDtoJSON.TAB*2 + '"uco-role":"https://ontology.unifiedcyberontology.org/uco/role/",\n', \
				UFEDtoJSON.TAB*2 + '"uco-location":"https://ontology.unifiedcyberontology.org/uco/location/",\n', \
				UFEDtoJSON.TAB*2 + '"uco-observable":"https://ontology.unifiedcyberontology.org/uco/observable/", \n', \
				UFEDtoJSON.TAB*2 + '"uco-tool":"https://ontology.unifiedcyberontology.org/uco/tool/", \n', \
				UFEDtoJSON.TAB*2 + '"uco-types":"https://ontology.unifiedcyberontology.org/uco/types/", \n', \
				UFEDtoJSON.TAB*2 + '"uco-vocabulary":"https://ontology.unifiedcyberontology.org/uco/vocabulary/", \n', \
#---	OLO is a method for representing lists, CASE doesn't really need to 
#		implement itself, implementing ordered lists in an OWL 2 DL compliant syntax.				
#				
				UFEDtoJSON.TAB*2 + '"olo":"http://purl.org/ontology/olo/core#", \n', \
				UFEDtoJSON.TAB*2 + '"xsd":"http://www.w3.org/2001/XMLSchema#" \n', \
				UFEDtoJSON.TAB*2 + '},\n', \
				'"@id":":bundle-' + uuid + '", \n', \
				'"@type":"uco-core:Bundle",\n', \
				'"uco-core:specVersion":"CASE 0.4 - UCO 0.6",\n', \
				'"uco-core:description":"Extraction from XML report generated by UFED PA",\n', \
				'"uco-core:object": [\n'])
		self.FileOut.write(line)

	def __generateLastLine(self):
		line = UFEDtoJSON.TAB + '] \n }'
		self.FileOut.write(line)

	def writeDevice(self, deviceId, devicePhoneModel, deviceOsType, deviceOsVersion, 
            devicePhoneVendor, deviceMacAddress, deviceIccid, deviceImsi, 
            deviceImei, deviceBluetoothAddress, deviceBluetoothName):

#---	generate Trace/Device for the mobile phone
#	
		self.DEVICE_uuid = self.__generateTraceDevice(deviceMacAddress, deviceId, devicePhoneModel,
			deviceOsType, deviceOsVersion, devicePhoneVendor, deviceMacAddress,
			deviceIccid, deviceImsi, deviceImei, deviceBluetoothAddress, deviceBluetoothName)

	
	def __generateTraceAppName(self, appName):
		
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[ 
				{ 
					"@type":"uco-observable:ApplicationFacet", 
					"uco-core:name":appName
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceAppIdentity(self, appName):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:IdentityFacet",
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:OrganizationFacet", 
					"uco-observable:orgName":appName
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __getMaxLenCallElement(self, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLidentifiersTO, 
					CALLidentifiersFROM):		
		maxLen = len(CALLrolesTO)
		
		if len(CALLrolesFROM) > maxLen:
			maxLen = len(CALLrolesFROM)
		if len(CALLnamesTO) > maxLen:
			maxLen = len(CALLnamesTO)
		if len(CALLnamesFROM) > maxLen:
			maxLen = len(CALLnamesFROM)
		if len(CALLidentifiersTO) > maxLen:
			maxLen = len(CALLidentifiersTO)
		if len(CALLidentifiersFROM) > maxLen:
			maxLen = len(CALLidentifiersFROM)
		return maxLen

	def writeCall(self, CALLid, CALLstatus, CALLsource, CALLtimeStamp, 
					CALLdirection, CALLduration, CALLrolesTO, CALLrolesFROM, 
					CALLnamesTO, CALLnamesFROM, CALLoutcome, CALLidentifiersTO, 
					CALLidentifiersFROM):
		
#---	each kind of phone call, further the traditional ones, are
#			processed, so the phonePattern is not necessary any more
#	
		phonePattern = '^\+?[0-9]+$'	# phone number pattern
		
		for i, call_id in enumerate(CALLid):
			
#---	there are two Parties, each of them with their own role
#						
			idPartyTO = ''
			idPartyFROM = ''
			idParty = ''
			nameParty =''
			
			maxLen = self.__getMaxLenCallElement(CALLrolesTO[i], CALLrolesFROM[i], 
					CALLnamesTO[i], CALLnamesFROM[i], CALLidentifiersTO[i], 
					CALLidentifiersFROM[i])
			
#---	all these arrays should have the same size, the check fill in the values.
#		if this is not the case, the loops make the size the same for all arrays
#
			for j in range(maxLen - len(CALLrolesTO[i])):
				CALLrolesTO[i].append('')
			
			for j in range(maxLen - len(CALLrolesFROM[i])):
				CALLrolesFROM[i].append('')
			
			for j in range(maxLen - len(CALLnamesTO[i])):
				CALLnamesTO[i].append('')
			
			for j in range(maxLen - len(CALLnamesFROM[i])):
				CALLnamesFROM[i].append('')
			
			for j in range(maxLen - len(CALLidentifiersTO[i])):
				CALLidentifiersTO[i].append('')
			
			for j in range(maxLen - len(CALLidentifiersFROM[i])):
				CALLidentifiersFROM[i].append('')
			
			if maxLen == 0:
				CALLrolesTO[i].append('')
				CALLrolesFROM[i].append('')
				CALLnamesTO[i].append('')
				CALLnamesFROM[i].append('')
				CALLidentifiersTO[i].append('')
				CALLidentifiersFROM[i].append('')

			if (len(CALLrolesFROM[i]) > 1):
				nameParty = ''
				if CALLrolesFROM[i][0].strip() == '':					
					idPartyFROM = CALLidentifiersFROM[i][1]
					nameFROM = CALLnamesFROM[i][1]
					idPartyTO 	= CALLidentifiersTO[i][0]
					nameTO = CALLnamesTO[i][0]
					nameParty = nameTO
				else:
					idPartyFROM = CALLidentifiersFROM[i][0]
					nameFROM = CALLnamesFROM[i][0]
					idPartyTO 	= CALLidentifiersTO[i][1]
					nameTO = CALLnamesTO[i][1]
			else:					
					if CALLrolesFROM[i][0].strip() == '':
						idPartyFROM = self.phoneOwnerNumber
						nameFROM = 'PHONE OWNER'
						idPartyTO		= CALLidentifiersTO[i][0]
						idParty = idPartyTO
						nameTO = CALLnamesTO[i][0]
						nameParty = nameTO
					else:						
						idPartyFROM		= CALLidentifiersFROM[i][0]
						idParty = idPartyFROM
						idPartyTO = self.phoneOwnerNumber
						nameFROM = CALLnamesFROM[i][0]
						nameParty = nameFROM
						nameTO = 'PHONE OWNER'
						
			resPattern = re.match(phonePattern, idParty.strip())

			if resPattern:
				if idPartyTO in self.phoneNumberList:
					idx = self.phoneNumberList.index(idPartyTO)
					uuidPartyTO = self.phoneUuidList[idx]
				else:	
	# if the mobile operator will be available in the XML report, it will be possible to 	
	#	define an object uco-identity:Identity related to the organisation. At the moment
	# the varibale is set to empty, so no the property uco-observable:accountIssuer is not 
	# included in the	uco-observable:PhoneAccount				
					mobileOperator = ""
					uuidPartyTO = self.__generateTracePhoneAccount(mobileOperator, 
						nameTO, idPartyTO)

				if idPartyFROM in self.phoneNumberList:
					idx = self.phoneNumberList.index(idPartyFROM)
					uuidPartyFROM = self.phoneUuidList[idx]
				else:	
	# if the mobile operator will be available in the XML report, it will be possible to 	
	#	define an object uco-identity:Identity related to the organisation. At the moment
	# the varibale is set to empty, so no the property uco-observable:accountIssuer is not 
	# included in the	uco-observable:PhoneAccount				
					mobileOperator = ""
					uuidPartyFROM = self.__generateTracePhoneAccount(mobileOperator, 
						nameFROM, idPartyFROM)

			else:
				idAppIdentity = self.__checkAppName(CALLsource[i].strip())	
				if idPartyFROM.strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(idPartyFROM.strip())
					uuidPartyFROM = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(nameFROM.strip())
					uuidPartyFROM = self.__generateTraceApplicationAccount(idPartyFROM.strip(), 
						nameFROM.strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(idPartyFROM.strip())
					self.CHATaccountIdList.append(uuidPartyFROM)
				
				if idPartyTO.strip() in self.CHATparticipantsIdList: 
					idx = self.CHATparticipantsIdList.index(idPartyTO.strip())
					uuidPartyTO = self.CHATaccountIdList[idx]
				else:
					self.CHATparticipantsNameList.append(nameTO.strip())
					uuidPartyTO = self.__generateTraceApplicationAccount(idPartyTO.strip(), 
						nameTO.strip(), idAppIdentity)
					self.CHATparticipantsIdList.append(idPartyTO.strip())
					self.CHATaccountIdList.append(uuidPartyTO)
							
			uuid = self.__generateTracePhoneCall(CALLdirection[i].lower(), 
				CALLtimeStamp[i], uuidPartyFROM, uuidPartyTO, CALLduration[i],
            	CALLstatus[i], CALLoutcome[i])
			self.__generateChainOfEvidence(call_id, uuid)


	def __generateTraceCalendar(self, calendar_id, status, group, subject, 
					details, startDate, endDate, repeatUntil, repeatInterval, 
					repeatRule):
		
		startDate = self.__cleanDate(startDate)
		
		endDate = self.__cleanDate(endDate)
		subject = self.__cleanJSONtext(subject)

		details = self.__cleanJSONtext(details)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:CalendarEntryFacet", 
					"not-in-ontology:group":group,
					"uco-observable:subject":subject,
					"not-in-ontology:details":details,
					"uco-observable:startTime":{
						"@type":"xsd:dateTime",
						"@value":startDate
					},
					"uco-observable:endTime":{
						"@type":"xsd:dateTime",
						"@value":endDate
					},					
					"not-in-ontology:repeatUntil":repeatUntil,
					"not-in-ontology:repeatInterval":repeatInterval
				}
			]
		}
		object_str = json.dumps(object_dict, indent=4)
		self.FileOut.write(object_str + ',\n')
		return uuid
		

	def __generateTraceCell_Tower(self, cell_id, cell_status, 
					cell_longitude, cell_latitude, cell_timeStamp, cell_mcc, 
					cell_mnc, cell_lac, cell_cid, cell_nid, cell_bid, cell_sid):
		
		cell_timeStamp = self.__cleanDate(cell_timeStamp)

		uuidLocation = self.__checkGeoCoordinates(cell_latitude, cell_longitude,
			 '', 'Cell Tower')
		
		uuid = ''
		if uuidLocation != '':

			cell_id = cell_mcc.strip() + '@' + cell_mnc.strip() +'@' + \
				cell_lac.strip() + '@' + cell_cid.strip()
			
	#---	identifier of the Cell Tower cannot be empty
	#			
			if cell_id == '@@@':
				return ''

			if cell_id in self.CELL_TOWER_gsm.keys():
	#---	return the Cell Tower's uuid generated sometime before
	#			
				return self.CELL_TOWER_gsm.get(cell_id)
			else:
				uuid = "kb:" + UFEDtoJSON.__createUUID()
				self.CELL_TOWER_gsm[cell_id] = uuid
				object_dict = {
					"@id":uuid,
					"@type":"uco-observable:ObservableObject",
					"uco-observable:hasChanged":True,
					"uco-core:hasFacet":[
						{
							"@type":"not-in-ontology:CellTowerFacet", 
							"not-in-ontology:mcc":cell_mcc,
							"not-in-ontology:mnc":cell_mnc,
							"not-in-ontology:lac":cell_lac,
							"not-in-ontology:cid":cell_cid,
							#"not-in-ontology:nid":cell_nid,
							#"not-in-ontology:bid":cell_bid,
							#"not-in-ontology:sid":cell_sid,
							"uco-observable:location":{
								"@id":uuidLocation
							}
						}
					]
				}
				object_str = json.dumps(object_dict, indent=4)
				self.FileOut.write(object_str + ',\n')
			
		return uuid
		
	def __generateTraceApplicationAccount(self, partyId, partyName, idApp):

		partyName = self.__cleanJSONtext(partyName)
		partyId = self.__cleanJSONtext(partyId)
		uuid = "kb:" + UFEDtoJSON.__createUUID()

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:AccountFacet", 
					"uco-observable:accountIdentifier":partyId,
					"uco-observable:isActive":True
				},
				{
					"@type":"uco-observable:ApplicationAccountFacet",
					"uco-observable:application":{
						"@id":idApp
					}
				},
				{
					"@type":"uco-observable:DigitalAccountFacet",
					"uco-observable:displayName":partyName
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent=4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceChat(self, body, idApplication, timeStamp, idFrom,
		idToList, status, outcome, direction, attachmentNames, 
		attachmentUrls):
		
		TOlist = ''
		for item in idToList:
#---	The idFROM shouldn't be part of the idTOlist unless there is only one 
#		Participant
#
			if item != idFrom:
				TOlist += '{"@id":"' + item + '"},'

#---	if the TO list is empty, idFROM and idTOlist will contain the same
#		identifier
#						
		if TOlist == '':
			TOlist += '{"@id":"' + idFrom + '"}'
		else:
			TOlist = TOlist[0:-1] 
		
		body = self.__cleanJSONtext(body)
		TOlist = TOlist.replace('\t', ' ')

		timeStamp = self.__cleanDate(timeStamp)


		uuid = self.__generateTraceMessageFacet(body, idApplication, idFrom, TOlist,
					timeStamp, status, 'CHAT Message')
		
#---	each Message, within a specific Chat can have more than one attachment,
#		both the Filenames and the Urls of the Attachment are separated by
# 		a triple hash tag # 
#		
		listFileNames = attachmentNames.split('###');
		listFileUrls = attachmentUrls.split('###');
		nName = len(listFileNames)
		nUrl = len(listFileUrls)
		if nName > nUrl:
			for i in range(nName - nUrl):
				listFileUrls.append('')
		if nName < nUrl:
			for i in range(nUrl - nName):
				listFileNames.append('')


		for i, file_name in enumerate(listFileNames):
			if (file_name.strip() != '') or \
			 	(listFileUrls[i].strip() != ''):
				fileUuid = self.__generateTraceFile(file_name, 
				'', '', '', 'Uncategorized', '', '', '', listFileUrls[i],
				'', '', '', '', '', '', '', '', '', '', '')
				
				if uuid != '':
					self.__generateTraceRelation(fileUuid, uuid, 'Connected_To', 
						'', '', '', '')
		return uuid


	def __generateTraceDevice(self, deviceMAC, deviceSN, deviceModel,
		deviceOS, deviceOSVersion, deviceManufacturer, deviceWiFi, deviceICCID,
		deviceIMSI, deviceIMEI, deviceBluetoothAddress, deviceBluetoothName):
		
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:DeviceFacet",
					"uco-observable:model":deviceModel,
					"uco-observable:serialNumber":deviceSN,
				},
				{
					"@type":"uco-observable:MobileDeviceFacet",
					"uco-observable:IMSI":deviceIMSI,
					"uco-observable:ICCID":deviceICCID,
					"uco-observable:IMEI":deviceIMEI,
				},
				{
					"@type":"uco-observable:OperatingSystemFacet",
					"uco-core:name":deviceOS,
					"uco-observable:manufacturer":deviceManufacturer,
					"uco-observable:version":deviceOSVersion,
				},
				{
					"@type":"uco-observable:BluetoothAddressFacet",
					"uco-core:name":deviceBluetoothName,
					"uco-observable:addressValue":deviceBluetoothAddress,
				},
				{
					"@type":"uco-observable:WifiAddressFacet",
					"uco-observable:addressValue":deviceWiFi
				}
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid
	
	def __generateTraceCookie(self, cookie_id, cookie_status, 
					cookie_source, cookie_name, cookie_value, cookie_domain, 
					cookie_creationTime, cookie_lastAccessedTime, cookie_expiry):
		
		cookie_creationTime = self.__cleanDate(cookie_creationTime)
		cookie_lastAccessedTime = self.__cleanDate(cookie_lastAccessedTime)
		cookie_expiry = self.__cleanDate(cookie_expiry)
		cookie_value = self.__cleanJSONtext(cookie_value)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:BrowserCookieFacet",
					"not-in-ontology:source":cookie_source,
					"uco-observable:cookieName":cookie_name,
					"uco-observable:cookiePath":cookie_value,
					"uco-observable:cookieDomain":cookie_domain,
					"uco-observable:observableCreatedTime":{
						"@type":"xsd:dateTime",
						"@value":cookie_creationTime
					},
					"uco-observable:lastAccessTime":{
						"@type":"xsd:dateTime",
						"@value":cookie_lastAccessedTime
					},
					"uco-observable:expirationTime":{
						"@type":"xsd:dateTime",
						"@value":cookie_expiry
					}
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceDeviceEvent(self, d_event_id, d_event_status, 
		d_event_timeStamp, d_event_eventType, d_event_value):

		d_event_timeStamp = self.__cleanDate(d_event_timeStamp)		
		d_event_value = self.__cleanJSONtext(d_event_value)
		
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EventFacet",
					"uco-observable:observableCreatedTime":{
						"@type":"xsd:dateTime",
						"@value":d_event_timeStamp
					},
					"uco-observable:eventType":d_event_eventType,
					"uco-observable:eventText":d_event_value
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __generateTraceEmail(self, EMAILid, EMAILstatus, EMAILsource, 
		EMAILidentifierFROM, EMAILidentifiersTO, EMAILidentifiersCC, 
		EMAILidentifiersBCC, EMAILbody, EMAILsubject, EMAILtimeStamp, 
		EMAILattachmentsFilename):

		if EMAILidentifierFROM.strip() in self.EMAILaddressList:
			idx = self.EMAILaddressList.index(EMAILidentifierFROM.strip())
			idFROM = self.EMAILaccountIdList[idx]
		else:
			self.EMAILaddressList.append(EMAILidentifierFROM.strip())
			uuidEmail = self.__generateTraceEmailAccount(EMAILidentifierFROM.strip())
			self.EMAILaccountIdList.append(uuidEmail)
			idFROM = uuidEmail

		itemsTO = ''
		for i, email_identifier in enumerate(EMAILidentifiersTO):
			if email_identifier.strip() != '':
				if email_identifier.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier.strip())
					idTO = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idTO = '{"@id":"' + uuidEmail + '"}'
				itemsTO += idTO + ','
		
		if itemsTO != '':
			itemsTO = json.loads(itemsTO[0:-1])

		itemsCC = ''
		for i, email_identifier_cc in enumerate(EMAILidentifiersCC):
			if email_identifier_cc.strip() != '':
				if email_identifier_cc.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier_cc.strip())
					idCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier_cc.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier_cc.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idCC = '{"@id":"' + uuidEmail + '"}'
				itemsCC += idCC + ','

#---	get rid of the last comma
#				
		itemsCC = itemsCC[0:-1]
		
		if itemsCC != '':
			itemsCC = json.loads(itemsCC)
		
		itemsBCC = ''
		for i, email_identifier_bcc in enumerate(EMAILidentifiersBCC):
			if email_identifier_bcc.strip() != '':
				if email_identifier_bcc.strip() in self.EMAILaddressList:
					idx = self.EMAILaddressList.index(email_identifier_bcc.strip())
					idBCC = '{"@id":"' + self.EMAILaccountIdList[idx] + '"}'
				else:
					self.EMAILaddressList.append(email_identifier_bcc.strip())
					uuidEmail = self.__generateTraceEmailAccount(email_identifier_bcc.strip())
					self.EMAILaccountIdList.append(uuidEmail)
					idBCC = '{"@id":"' + uuidEmail + '"}'
				itemsBCC += idBCC + ','

		# get rid of the last comma
		itemsBCC = itemsBCC[0:-1]
		
		if itemsBCC != '':
			itemsBCC = json.loads(itemsBCC)

		body = self.__cleanJSONtext(EMAILbody)		
		subject = self.__cleanJSONtext(EMAILsubject)
		EMAILtimeStamp = self.__cleanDate(EMAILtimeStamp)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject",
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EmailMessageFacet",
					"uco-observable:sentTime":
					{
						"@type":"xsd:dateTime",
						"@value":EMAILtimeStamp 	
					},
					"uco-observable:isMimeEncoded":False,
					"uco-observable:isMultipart":False,
					"uco-observable:from":
					{
						"@id":idFROM 
					},
					"uco-observable:to":[
						itemsTO
					],
					"uco-observable:cc":[
						itemsCC
					],
					"uco-observable:bcc":[
						itemsBCC
					],
					"uco-observable:body":body,
					"uco-observable:subject":subject,
					"uco-observable:allocationStatus":EMAILstatus
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		self.__generateChainOfEvidence(EMAILid, uuid)

		for i, email_attachment in enumerate(EMAILattachmentsFilename):
			if email_attachment.strip() != '':
				fileUuid = self.__generateTraceFile(email_attachment, 
				'', '', '', 'Uncategorized', '', '', '', '',
  				'', '', '', '', '', '', '', '', '', '', '')
				self.__generateTraceRelation(fileUuid, uuid, 'Attached_To', 
				'', '', '', '')
		return uuid

	def __generateTraceEmailAccount(self, address):
		
		address = self.__cleanJSONtext(address) 
		uuidAddress = self.__generateTraceEmailAddress(address)

		uuid = "kb:" + UFEDtoJSON.__createUUID()		
		uuidAddress = '{"@id":"' + uuidAddress + '"}'
		uuidAddress = json.loads(uuidAddress)
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:AccountFacet",
						"uco-observable:isActive":True,
						"uco-observable:accountIdentifier":"",
					},
					{
						"@type":"uco-observable:EmailAccountFacet",
						"uco-observable:emailAddress":uuidAddress
					}
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid

	def __generateTraceEmailAddress(self, address):		
		address = self.__cleanJSONtext(address)
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
			"@id":uuid,			
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:EmailAddressFacet", 
					"uco-observable:addressValue":address
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceFile(self, FILEpath, FILEsize, FILEhashType, 
		FILEHashValue, FILETag, FILEtimeC, FILEtimeM, FILEtimeA, FILElocalPath, 
		FILEiNode, FILEiNodeTimeM, FILEgid, FILEuid, FILEexifLatitudeRef, FILEexifLatitude, 
		FILEexifLongitudeRef, FILEexifLongitude, FILEexifAltitude, FILEexifMake, FILEexifModel):		
		head, tail = os.path.split(FILEpath)
		
		tail = self.__cleanJSONtext(tail)
		path = FILEpath.replace('"', "").replace('\n', '').replace('\r', '')
		path = path.replace("\\", "/")
		
		dotPos = tail.find('.')
		if dotPos > -1:
			sExt = tail[dotPos:]
		else:
			sExt = ''
		
		if FILEHashValue.upper() == 'N/A':
			FILEHashValue = UFEDtoJSON.HASH_V

		if FILEHashValue.strip() == '':
				FILEHashValue = UFEDtoJSON.HASH_V

		if FILEhashType.strip() == '':
			FILEhashType = UFEDtoJSON.HASH_M

		if FILEhashType.upper() == '_NOT_PROVIDED_':
			FILEhashType = UFEDtoJSON.HASH_M	

		if FILETag.upper() == '_NOT_PROVIDED_':
			FILETag = 'Uncategorized';			
		
		line_hash = ''
		if  FILEsize.strip != '0':
			line_hash = (
				',{'
				'"@type":"uco-observable:ContentDataFacet",'
				'"uco-observable:hash":['
					'{'
						'"@type":"uco-types:Hash",'
						'"uco-types:hashMethod":{'
							'"@type":"uco-vocabulary:HashNameVocab",'
							'"@value":"' + FILEhashType + '"'
						'},'
						'"uco-types:hashValue":{'
							'"@type":"xsd:hexBinary",'
							'"@value":"' + FILEHashValue + '"'
						'}'
					'}'
				']'
			'}'
			)

#--- Replace all not number occurrences with nothing
#		
		FILEsize = re.sub('[^0-9]','', FILEsize)
		if FILEsize.strip() == '':
			FILEsize = UFEDtoJSON.INT;
		
		FILEtimeC = self.__cleanDate(FILEtimeC)
		FILEtimeM = self.__cleanDate(FILEtimeM)
		FILEtimeA = self.__cleanDate(FILEtimeA)			
		FILEiNodeTimeM = self.__cleanDate(FILEiNodeTimeM)

		FILEiNode = FILEiNode.strip()
		if FILEiNode.strip() == '':
			FILEiNode = UFEDtoJSON.INT	
		
		if FILEiNode.find('0x') > - 1:
			FILEiNode = int(FILEiNode, 16)

		FILEuid = FILEuid.strip()
		if FILEuid.strip() == '':
			FILEuid = UFEDtoJSON.INT	

		if FILEuid.find('0x') > - 1:
			FILEuid = int(FILEuid, 16)
		
		FILEgid = FILEgid.strip()
		if FILEgid.strip() == '':
			FILEgid = UFEDtoJSON.INT

		if FILEgid.find('0x') > - 1:
			FILEgid = int(FILEgid, 16)
		
		localPath = FILElocalPath.replace('"', "").replace('\n', '').replace('\r', '')
		localPath = localPath.replace("\\", "/")

		line_exif = ''
		if FILEexifLatitude.strip() != '':
			line_exif = (
				',{' 
				'"@type":"uco-observable:EXIFFacet",' 
				'"uco-observable:exifData":{'
					'"@type":"uco-types:ControlledDictionary",'
					'"uco-types:entry":['
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"Make",'
							'"uco-types:value":"' + FILEexifMake + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"Model",'
							'"uco-types:value":"' + FILEexifModel + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"LatitudeRef",'
							'"uco-types:value":"' + FILEexifLatitudeRef + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"Latitude",'
							'"uco-types:value":"' + FILEexifLatitude + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"LongitudeRef",'
							'"uco-types:value":"' +FILEexifLongitudeRef + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"Longitude",'
							'"uco-types:value":"' + FILEexifLongitude + '"'
						'},'
						'{'
							'"@type":"uco-types:ControlledDictionaryEntry",'
							'"uco-types:key":"Altitude",'
							'"uco-types:value":"' + FILEexifAltitude + '"'
						'}'
					']'
				'}'
			'}'
			)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict_str = (
			'{'			
				'"@id":"' + uuid + '",'			
				'"@type":"uco-observable:ObservableObject",'
				'"uco-observable:hasChanged":true,'
				'"uco-core:tag":["' + FILETag + '"],'
				'"uco-core:hasFacet":['
					'{'
						'"@type":"uco-observable:FileFacet",'
						'"uco-observable:fileName":"' + tail + '",'
						'"uco-observable:filePath":"' + path + '",'
						'"uco-observable:fileLocalPath":"' + localPath + '",'
						'"uco-observable:extension":"' + sExt + '",'
						'"uco-observable:fileSystemType":"userdata (ExtX)",'
						'"uco-observable:isDirectory":false,'
						'"uco-observable:sizeInBytes": {'
							'"@type":"xsd:integer",'
							'"@value":"' + FILEsize + '"'
						'},'
						'"uco-core:objectCreatedTime":{'
							'"@type":"xsd:dateTime",'
							'"@value":"' + FILEtimeC + '"'
						'},'
						'"uco-core:objectModifiedTime":{'
							'"@type":"xsd:dateTime",'
							'"@value":"' + FILEtimeM + '"'
						'},'
						'"uco-core:objectAccessedTime":{'
							'"@type":"xsd:dateTime",'
							'"@value":"' + FILEtimeA + '"'
						'}'
					'},'
					'{'
						'"@type":"uco-observable:ExtInodeFacet",'
						'"uco-observable:extInodeID":{'
							'"@type":"xsd:integer",'
							'"@value":"' + str(FILEiNode) + '"'
					'},'
					'"uco-observable:extSGID":{'
						'"@type":"xsd:integer",'
						'"@value":"' + str(FILEgid) + '"'
					'},'
					'"uco-observable:extSUID":{'
						'"@type":"xsd:integer",'
						'"@value":"' + str(FILEuid) + '"'
					'},'
					'"uco-observable:extInodeChangeTime":{'
						'"@type":"xsd:dateTime",'
						'"@value":"' + FILEiNodeTimeM + '"'
					'}'
				'}'
				 '' + line_hash + ''
				 '' + line_exif + ''
				']'
			'}'
		)

		object_dict = json.loads(object_dict_str)
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __generateTraceIdentity(self, name, familyName, birthDate):		
		birthDate = self.__cleanDate(birthDate)
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		
		object_dict = {			
			"@id":uuid,
			"@type":"uco-identity:Identity",
			"uco-core:hasFacet":[
				{
					"@type":"uco-identity:SimpleNameFacet",
					"uco-identity:givenName":name,
					"uco-identity:familyName":familyName
				},
				{
					"@type":"uco-identity:BirthInformationFacet",
					"uco-identity:birthdate":{
						"@type":"xsd:dateTime",
						"@value":birthDate
					}
				}
			]
		}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid


	def __generateTraceLocationDevice(self, loc_id, loc_status, 
					loc_longitude, loc_latitude, loc_elevation,
					loc_timeStamp, loc_category):
		
		location_timeStamp = self.__cleanDate(loc_timeStamp)
		uuidLocation = self.__checkGeoCoordinates(loc_latitude, loc_longitude,
			loc_elevation, loc_category)

		return uuidLocation

	def __generateTracePhoneAccount(self, source, name, phone_num):
		
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[ 
					{
						"@type":"uco-observable:AccountFacet", 
						"uco-observable:accountIssuer":source,
						"uco-observable:isActive":True,
						"uco-observable:accountIdentifier":""
					},
					{
						"@type":"uco-observable:PhoneAccountFacet",
						"uco-observable:phoneNumber":phone_num,
						"uco-core:name":name
					} 
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid

	def __generateTraceInvestigativeAction(self, name, description, startTime, endTime, 
		idInstrument, location, idPerformer, idObject, listResult, endChar):
		
		n = len(listResult)
		lineResult = ''
		for i in range(n - 1):
			lineResult += '{"@id":"' + listResult[i] + '"},'

		if n > 0:
			lineResult += '[{"@id":"' + listResult[n - 1]  + '"}]'


		lineResult = json.loads(lineResult)
		startTime = self.__cleanDate(startTime)
		endTime = self.__cleanDate(endTime)

		if location.strip() == '':
			location = UFEDtoJSON.LOC

		uuidLocation = self.__generateTraceLocation(location)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"case-investigation:InvestigativeAction",
				"uco-core:name":name,
				"uco-core:description":description,
				"uco-action:startTime":{
					"@type":"xsd:dateTime",
					"@value":startTime
				},
				"uco-action:endTime":{
					"@type":"xsd:dateTime",
					"@value":endTime,
				},
				"uco-core:hasFacet":[
					{
						"@type":"uco-action:ActionReferencesFacet",
						"uco-action:instrument":{
							"@id":idInstrument
						},
						"uco-action:location":{
							"@id":uuidLocation
						},
						"uco-action:performer":{
							"@id":idPerformer
						},
						"uco-action:object":[
							{"@id":idObject}
						],
						"uco-action:result":lineResult
					}
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + endChar)

		return uuid

	def __generateTracePhoneCall(self, direction, startTime, idFROM, idTO, 
								duration, status, outcome):

		nTime = 0
		if duration != "":
			aTime = duration.split(":")
			if len(aTime) == 3:
				if aTime[2].find('.') > -1:
					aTime[2] = aTime[2][0:aTime[2].find('.')]
				if aTime[2].find(',') > -1:
					aTime[2] = aTime[2][0:aTime[2].find(',')]

				nTime = int(aTime[0])*3600 + int(aTime[1])*60 + int(aTime[2])
			if len(aTime) == 2:
				nTime = int(aTime[0])*60 + int(aTime[1]) 
			if len(aTime) == 1:
				nTime = int(aTime[0]) 
		duration = str(nTime)
		duration = duration.lstrip('0')
		if duration == "":
			duration = "0"
		
		point = duration.find('.') 
		if point > - 1:
			duration = duration[0:point]
		
		idAppIdentity = self.__checkAppName("Native")
		startTime = self.__cleanDate(startTime)

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:PhoneCallFacet", 
						"uco-observable:callType":direction,
						"uco-observable:startTime":{
							"@type":"xsd:dateTime",
							"@value":startTime
						},
						"uco-observable:application":{
							"@id":idAppIdentity
						},
						"uco-observable:from":{
							"@id":idFROM
						},
						"uco-observable:to":{
							"@id":idTO
						},
						"uco-observable:duration":{
							"@type":"xsd:integer",
							"@value":duration
						},
						"uco-observable:allocationStatus":status
					}
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		return uuid
	

	def __generateTracePhoneOwner(self, source, name, phone_num):
				
		name += ' (Owner)'
		self.phoneOwnerUuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":self.phoneOwnerUuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[ 
					{
						"@type":"uco-observable:AccountFacet", 
						"uco-observable:isActive":True,
						"uco-observable:accountIdentifier":""
					},			
					{
						"@type":"uco-observable:PhoneAccountFacet", 
						"uco-observable:phoneNumber":phone_num,
						"uco-observable:accountIssuer":source,
						"uco-core:name":name
					}
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')

		self.phoneNumberList.append(phone_num)
		self.phoneUuidList.append(self.phoneOwnerUuid)

	def __generateTraceProvencance(self, idTracesList, description, 
		exhibitNumber, creationTime):
		
		n = len(idTracesList)
		lineTraces = ''		
		for idx in range(n - 1):
			lineTraces += '{"@id":"' + idTracesList[idx] + '"},'

		if n > 0:
			lineTraces = '['  + lineTraces + '{"@id":"' + idTracesList[n - 1] + '"}]'

		if lineTraces != '':
			lineTraces = json.loads(lineTraces)

		
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"case-investigation:ProvenanceRecord",			
				"case-investigation:exhibitNumber":exhibitNumber,
				"uco-core:object":lineTraces			
			}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceRelation(self, source, target, relation, table, offset,
		start_date, end_date):
		
		start_date = self.__cleanDate(start_date)
		end_date = self.__cleanDate(end_date)

		cleanOffset = offset.replace('@', '')
		lineTable = ''
		if not table == '':			
			lineTable = {
				"@type":"uco-observable:DataRangeFacet",
				"uco-observable:rangeOffset": {
					"@type":"xsd:integer",
					"@value":cleanOffset
				},
				"uco-observable:rangeSize": {
					"@type":"xsd:integer",
					"@value":"0"
				}
			}

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableRelationship",
				"uco-observable:startTime":{
					"@type":"xsd:dateTime",
					"@value":start_date
				},
				"uco-observable:endTime":{
					"@type":"xsd:dateTime",
					"@value":end_date
				},
				"uco-core:source":{
					"@id":source
				},
				"uco-core:target":{
					"@id":target 
				},
				"uco-core:kindOfRelationship":relation,				
				"uco-core:isDirectional":True,
				"uco-core:hasFacet":[
					lineTable
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceRole(self, role):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id": uuid,
			"@type":"uco-role:Role",
			"uco-core:name":role					
		}

		object_str = json.dumps(object_dict, indent=4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceSocialMedia_Item(self, sm_item_id, sm_status, 
					sm_source, sm_timeStamp, sm_body,
					sm_title, sm_url, sm_identifier, sm_name, sm_reactionsCount, 
					sm_sharesCount, sm_activityType, sm_commentCount, sm_account):

		if sm_source.strip() != '': 
			id_app = self.__checkAppName(sm_source.strip())
			sm_app_str = json.loads('{"@id":"' + id_app + '"}')
		else:
			sm_app_str = ''		

		sm_timeStamp = self.__cleanDate(sm_timeStamp)
		sm_title = self.__cleanJSONtext(sm_title)
		sm_body = self.__cleanJSONtext(sm_body)
		sm_url = self.__cleanJSONtext(sm_url)
		
		if sm_url != '':
			uuidUrl = self.__checkUrlAddress(sm_url)
			sm_url_str = '{"@id":"' + uuidUrl + '"}'
		else:
			sm_url_str = '""'

		sm_url_str = json.loads(sm_url_str)

		if (sm_body == '' and sm_source.strip() == ''):
			return ''

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"not-in-ontology:SocialMediaActivityFacet",
						"uco-observable:application":sm_app_str,
						"uco-observable:observableCreatedTime":{
							"@type":"xsd:dateTime",
							"@value":sm_timeStamp
						},
						"uco-observable:body":sm_body,
						"uco-observable:pageTitle":sm_title,
						"uco-observable:url":sm_url_str,
						"not-in-ontology:authorIdentifier":sm_identifier,
						"not-in-ontology:authorName":sm_name,
						"not-in-ontology:reactionsCount":sm_reactionsCount,
						"not-in-ontology:sharesCount":sm_sharesCount,
						"not-in-ontology:activityType":sm_activityType,
						"not-in-ontology:commentCount":sm_commentCount,
						"uco-observable:accountIdentifier":sm_account
					}
				]
			}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceSearched_Item(self, search_id, search_status, 
					search_source, search_timestamp, search_value, search_result):
		
		search_value = self.__cleanJSONtext(search_value)
		
		if search_value.strip() == '' and search_result.strip() == '':
			return ''
		
		search_result = self.__cleanJSONtext(search_result)
		search_timestamp = self.__cleanDate(search_timestamp)

		if not self.__checkSearchedItems(search_value + search_timestamp):
			return ''		

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"not-in-ontology:SearchedItemFacet", 
						"not-in-ontology:searchSource":search_source,
						"not-in-ontology:searchLaunchedTime":{
							"@type":"xsd:dateTime",
							"@value":search_timestamp
						},
					"not-in-ontology:searchValue":search_value,
					"not-in-ontology:searchResult":search_result
					}
				]				
			}
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceWireless_Net(self, wnet_id, wnet_status, 
					wnet_longitude, wnet_latitude, wnet_timeStamp, wnet_last_connection, 
					wnet_bssid, wnet_ssid):

		wnet_timeStamp = self.__cleanDate(wnet_timeStamp)
		wnet_last_connection = self.__cleanDate(wnet_last_connection)
		
		uuidLocation = self.__checkGeoCoordinates(wnet_latitude, wnet_longitude, 
				'', 'Wireless Network')					
#---	identifier of the Wirelesss Network cannot be empty
#			
		if uuidLocation == '':
			return ''
			
		wnet_id = wnet_bssid.strip() + '@' + wnet_ssid.strip()
		if wnet_id == '@':
			return ''
		else:
			if wnet_id in self.WIRELESS_NET_ACCESS.keys():
				uuid = self.WIRELESS_NET_ACCESS.get(wnet_id)
			else:									
				uuid = "kb:" + UFEDtoJSON.__createUUID()
				self.WIRELESS_NET_ACCESS[wnet_id] = uuid
			
				uuid = "kb:" + UFEDtoJSON.__createUUID()
				object_dict = {			
					"@id":uuid,
					"@type":"uco-observable:ObservableObject",
					"uco-observable:hasChanged":True,
					"uco-core:hasFacet":[
						{
							"@type":"uco-observable:WirelessNetworkConnectionFacet",
							"uco-observable:ssid":wnet_ssid,
							"not-in-ontology:bssid":wnet_bssid,
							"not-in-ontology:timeConnection":{
								"@type":"xsd:dateTime",
								"@value":wnet_timeStamp
							},
						"not-in-ontology:lastConnection":{
							"@type":"xsd:dateTime",
							"@value":wnet_last_connection
							},
							"uco-observable:location":{
								"@id":uuidLocation
							}
						}
					]
				}
				
				object_str = json.dumps(object_dict, indent = 4)
				self.FileOut.write(object_str + ',\n')
			return uuid

	def __generateTraceMessageFacet(self, body, id_app, phone_uuid_from, phone_uuid_to, 
			time_stamp, status, type):

		if type == 'SMS/Native Message':
			type_class = 'uco-observable:SMSMessageFacet'
		else:
			type_class = 'uco-observable:MessageFacet'

		time_stamp = self.__cleanDate(time_stamp)
		body = self.__cleanJSONtext(body)
		
		#str_from = json.loads(str_from)

		#phone_uuid_to = json.loads(phone_uuid_to)

		if body.strip() == ''  	and \
			phone_uuid_to == '' and \
			phone_uuid_from == '' :
			return ''
		phone_uuid_to = json.loads('[' + phone_uuid_to + ']')
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {			
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":type_class,
						"uco-observable:messageText":body,
						"uco-observable:application":{
							"@id":id_app
						},
						"uco-observable:messageType":type,
						"uco-observable:allocationStatus":status,
						"uco-observable:from":{
							"@id":phone_uuid_from
						},
						"uco-observable:to":
							phone_uuid_to,
						"uco-observable:sentTime":{
							"@type":"xsd:dateTime",
							"@value":time_stamp
						}
					}
				]
			}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceSms(self, SMSid, SMSstatus, SMStimeStamp, 
							SMSpartyRoles, SMSpartyIdentifiers, 
							SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource):		
		for i, sms_id in enumerate(SMSid):
			phoneUuidTo = ''
			phoneUuidFrom = ''
			for j, sms_party_identifier in enumerate(SMSpartyIdentifiers[i]):				
				if sms_party_identifier.strip() != '':
					if sms_party_identifier in self.phoneNumberList:						
						idx = self.phoneNumberList.index(sms_party_identifier)						
						userId = self.phoneNumberList[idx]
						phonePartyUuid = self.phoneUuidList[idx]
					else:
# see previous comment of the use of the mobileOperator variable
						self.phoneNumberList.append(sms_party_identifier)
						self.phoneNameList.append(SMSpartyNames[i][j])
						mobileOperator = ""
						phonePartyUuid = self.__generateTracePhoneAccount(mobileOperator, 
							SMSpartyNames[i][j], sms_party_identifier)	
						self.phoneUuidList.append(phonePartyUuid)
				
					phoneUuidTo = ''
	        		# Party with Role=TO can be more than one
					if SMSpartyRoles[i][j] == 'To':
						phoneUuidFrom = self.phoneOwnerUuid
						phoneUuidTo += '{"@id":"' + phonePartyUuid + '"}' + ','
					else:
						phoneUuidFrom = phonePartyUuid
						phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'
			
			phoneSmscUuid = ''
			if SMSsmsc[i].strip() != '':
				if SMSsmsc[i].strip() in self.phoneNumberList:						
					idx = self.phoneNumberList.index(SMSsmsc[i].strip())						
					userId = self.phoneNumberList[idx]
					phoneSmscUuid = self.phoneUuidList[idx]
				else:
					self.phoneNumberList.append(SMSsmsc[i].strip())
					self.phoneNameList.append('SMSC')
					mobileOperator = ""
					phoneSmscUuid = self.__generateTracePhoneAccount(mobileOperator, 
						'SMSC', SMSsmsc[i].strip())	
					self.phoneUuidList.append(phoneSmscUuid)

			if SMSfolder[i] == 'Inbox':
				if phoneUuidFrom.strip() == '':
						phoneUuidFrom = phoneSmscUuid
			else:
				if phoneUuidTo.strip() == '':
						phoneUuidTo = phoneSmscUuid	

			if self.phoneOwnerUuid.strip() != '':
				if phoneUuidTo == self.phoneOwnerUuid:
					phoneUuidTo = '{"@id":"' + self.phoneOwnerUuid + '"}'	
				else:
					if phoneUuidTo != '':
						if phoneUuidTo[-1] == ',':
							phoneUuidTo = phoneUuidTo[0:-1]

			body = self.__cleanJSONtext(SMSbody[i])
			
#---	the xsd:dateTime has the structure YYYY-MM-DDTHH:MM:SS (UTCxxx
#		the character "/" is not allowed
#		
			SMStimeStamp[i] = self.__cleanDate(SMStimeStamp[i])

			id_app_name = self.__checkAppName("Native")

			direction = ''
			uuid = self.__generateTraceMessageFacet(body, id_app_name, phoneUuidFrom, phoneUuidTo,
					SMStimeStamp[i], SMSstatus[i], 'SMS/Native Message')

			if uuid != '':
				self.__generateChainOfEvidence(sms_id, uuid)

	def __generateThreadMessages(self, chatTraceId, chatThread, chat_id_to):
		
		nChatThread = len(chatThread)
		line_thread  = ''
		for i in range(nChatThread):
			line_thread += '{'
			line_thread += '"olo:index":"' + str(i + 1) + '",'
			line_thread += '"olo:item": {'
			line_thread += '"@id":"' + chatThread[i] + '"'
			line_thread += '}'
			line_thread += '},'
		
		line_thread = json.loads('[' + line_thread[0:-1] + ']')

		nChatAccounts = len(chat_id_to)
		lineChatAccounts = ''	
		for i, account_id in enumerate(chat_id_to):
			lineChatAccounts += '{"@id":"' + str(account_id) + '"},'

		lineChatAccounts = json.loads('[' + lineChatAccounts[0:-1] + ']')
		len_chat_thread = str(len(chatThread))

		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
				"@id":uuid,
				"@type":"uco-observable:ObservableObject",
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:MessageThreadFacet",
						"uco-observable:displayName":"",
						"uco-observable:message":{
							"@type":"uco-observable:Message", 
							"uco-observable:hasChanged":True,
							"olo:length":len_chat_thread,
							"olo:slot":line_thread
						},
						"uco-observable:participant":lineChatAccounts
				}			
			]
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceTool(self, name, type, vendor, version, confList):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-tool:Tool", 
			"uco-core:name":name,
			"uco-tool:toolType":type,
			"uco-tool:creator":vendor,
			"uco-tool:version":version
		}

		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceURLFullValue(self, URL_Value):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-observable:URLFacet", 
					"uco-observable:fullValue":URL_Value
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceURL(self, URL_Value):
		
		URL_Value = self.__cleanJSONtext(URL_Value)
		startHttp = URL_Value.strip().find('http')
		
		if startHttp > - 1:
			URL_Value = URL_Value[startHttp:]

		uuid = self.__checkUrlAddress(URL_Value)
				
		return uuid

	def __generateTraceLocation(self, Location):
		
		Location = Location.strip()
		if Location in self.LocationList: 
					idx = self.LocationList.index(Location)
					uuid = self.LocationIDList[idx]
		else:
			uuid = "kb:" + UFEDtoJSON.__createUUID()
			self.LocationList.append(Location)
			self.LocationIDList.append(uuid)
			object_dict = {
				"@id":uuid,
				"@type":"uco-location:Location", 
				"uco-core:hasFacet":[
					{
						"@type":"uco-location:SimpleAddressFacet", 
						"uco-location:locality":Location
					}
				]
			}

			object_str = json.dumps(object_dict, indent = 4)
			self.FileOut.write(object_str + ',\n')
		
		return uuid

	def __generateTraceLocationCoordinate (self, latitude, longitude, altitude, type):
		uuid = "kb:" + UFEDtoJSON.__createUUID()
		id = latitude + '@' + longitude
		self.LOCATION_lat_long_coordinate[id] = uuid

		object_dict = {
			"@id":uuid,
			"@type":"uco-observable:ObservableObject", 
			"uco-observable:hasChanged":True,
			"uco-core:hasFacet":[
				{
					"@type":"uco-location:LatLongCoordinatesFacet",
					"uco-location:altitude":altitude,
					"uco-location:latitude":latitude,
					"uco-location:longitude":longitude,
					"not-in-ontology:locationType":type
				}
			]
		}
		
		object_str = json.dumps(object_dict, indent = 4)
		self.FileOut.write(object_str + ',\n')
		return uuid

	def __generateTraceWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGElastVisited):

		for i, web_page_id in enumerate(WEB_PAGEid):			
			
			WEB_PAGElastVisited[i] = self.__cleanDate(WEB_PAGElastVisited[i])
			idAppIdentity = self.__checkAppName(WEB_PAGEsource[i].strip())
			uuidUrl = self.__generateTraceURL(WEB_PAGEurl[i])
			title = self.__cleanJSONtext(WEB_PAGEtitle[i])
			
			if WEB_PAGEvisitCount[i].strip() == '':
				visit_count = '0' 
			else:
				visit_count = WEB_PAGEvisitCount[i]

			uuid = "kb:" + UFEDtoJSON.__createUUID()

			object_dict = {
				"@id":uuid,
				"@type":"uco-observable:ObservableObject", 			
				"uco-observable:hasChanged":True,
				"uco-core:hasFacet":[
					{
						"@type":"uco-observable:URLHistoryFacet", 
						"uco-observable:browserInformation":
							{
								"@id":idAppIdentity
							}
					},
					{	
						"@type":"uco-observable:urlHistoryEntry",
						"uco-observable:firstVisit":{
							"@type":"xsd:dateTime",
							"@value":"1900-01-01T08:00:00"
						},
						"uco-observable:lastVisit":{
							"@type":"xsd:dateTime",
							"@value":WEB_PAGElastVisited[i]
						},
						"uco-observable:expirationTime":{
							"@type":"xsd:dateTime",
							"@value":"1900-01-01T08:00:00"
						},
						"uco-observable:url":{
							"@id":uuidUrl
						},
						"uco-observable:pageTitle":title,
						"uco-observable:visitCount":visit_count, 			
						"uco-observable:manuallyEnteredCount":{
							"@type":"xsd:nonNegativeInteger",
							"@value":"0"
						},
						"uco-observable:keywordSearchTerm":"NULL",
						"uco-observable:allocationStatus":WEB_PAGEstatus[i]					
					}
				]
			}
			
			object_str = json.dumps(object_dict, indent = 4)
			self.FileOut.write(object_str + ',\n')
			self.__generateChainOfEvidence(web_page_id, uuid, endChar='')

#---	it is not used anymore, every time the field Source is extracted
#		an uco-observable:Application item is created
#			
	def storeUserAccount(self, U_ACCOUNTsource, U_ACCOUNTname,
			U_ACCOUNTusername):
		for i, u_account_source in enumerate(U_ACCOUNTsource):
			idAppName = self.__generateTraceAppName(u_account_source)
			self.appNameList.append(u_account_source)
			self.appIDList.append(idAppName)


	def writeExtraInfo(self, EXTRA_INFOdictPath, EXTRA_INFOdictSize, EXTRA_INFOdictTableName, 
				EXTRA_INFOdictOffset, EXTRA_INFOdictNodeInfoId):
		self.EXTRA_INFOdictPath = EXTRA_INFOdictPath
		self.EXTRA_INFOdictSize = EXTRA_INFOdictSize
		self.EXTRA_INFOdictTableName = EXTRA_INFOdictTableName
		self.EXTRA_INFOdictOffset = EXTRA_INFOdictOffset
		self.EXTRA_INFOdictNodeInfoId = EXTRA_INFOdictNodeInfoId		

	def writeContact(self, CONTACTid, CONTACTstatus, CONTACTsource, 
            CONTACTname, CONTACTuserIds, CONTACTphoneNums, CONTACTaccount):
		for i, contact in enumerate(CONTACTid):
			for j, phoneNum in enumerate(CONTACTphoneNums[i]):
				if phoneNum.strip() != '':
					self.__checkPhoneNumber(phoneNum.strip(), CONTACTname[i])
			
			#if 	CONTACTaccount[i].strip() != '':				
				#self.__checkAccountName(CONTACTaccount[i], CONTACTname[i], idApp)
			if CONTACTuserIds[i][0].strip() != '':
				idApp = self.__checkAppName(CONTACTsource[i])
				self.__checkAccountName(CONTACTuserIds[i][0].strip(), CONTACTname[i], idApp)
					

	def writeHeader(self):
		self.__generateHeader()

	def writeLastLine(self):
		self.__generateLastLine()

	def writePhoneOwner(self, phoneOwnerNumber):
		self.phoneOwnerNumber = phoneOwnerNumber
		mobileOperator = ""
		mobileOwnerName = ""
		self.__generateTracePhoneOwner(mobileOperator, mobileOwnerName, phoneOwnerNumber)

	def writeFiles(self, FILEid, FILEpath, FILEsize, FILEmd5, FILETag, 
					FILEtimeCreate, FILEtimeModify, FILEtimeAccess, FILElocalPath, 
                    FILEiNodeNumber, FILEiNodeTimeM, FILEownerGID, FILEownerUID,
                    FILEexifLatitudeRef, FILEexifLatitude, FILEexifLongitudeRef,
                    FILEexifLongitude, FILEexifAltitude, FILEexifMake, FILEexifModel):
			self.FILEid = FILEid
			for i, file_id in enumerate(FILEid):					
				uuid = self.__generateTraceFile(FILEpath[i], FILEsize[i], 
					'MD5', FILEmd5[i],	FILETag[i], FILEtimeCreate[i], FILEtimeModify[i], 
					FILEtimeAccess[i], FILElocalPath[i], FILEiNodeNumber[i], FILEiNodeTimeM[i],
					FILEownerGID[i], FILEownerUID[i], FILEexifLatitudeRef[i], 
					FILEexifLatitude[i], FILEexifLongitudeRef[i], FILEexifLongitude[i], 
					FILEexifAltitude[i], FILEexifMake[i], FILEexifModel[i])

				self.FILEuuid[file_id] = uuid
				self.FILEpath[file_id] = FILEpath[i]

	def writeCalendar(self, CALENDARid, CALENDARstatus, CALENDARcategory, CALENDARsubject,
                    CALENDARdetails, CALENDARstartDate, CALENDARendDate, CALENDARrepeatUntil, 
                    CALENDARrepeatDay, CALENDARrepeatInterval):
		
		for i, calendar_id in enumerate(CALENDARid):
			uuid= self.__generateTraceCalendar(calendar_id, CALENDARstatus[i], 
					CALENDARcategory[i], CALENDARsubject[i], CALENDARdetails[i], 
					CALENDARstartDate[i], CALENDARendDate[i], CALENDARrepeatUntil[i], 
                    CALENDARrepeatDay[i], CALENDARrepeatInterval[i])
			
			self.__generateChainOfEvidence(calendar_id, uuid)

	def writeCell_Tower(self, CELL_TOWERid, CELL_TOWERstatus, CELL_TOWERlongitude, 
					CELL_TOWERlatitude, CELL_TOWERtimeStamp, CELL_TOWERmcc,
                    CELL_TOWERmnc, CELL_TOWERlac, CELL_TOWERcid, CELL_TOWERnid, 
                    CELL_TOWERbid, CELL_TOWERsid):
		
		for i, cell_tower_id in enumerate(CELL_TOWERid):
			uuid= self.__generateTraceCell_Tower(cell_tower_id, CELL_TOWERstatus[i], 
					CELL_TOWERlongitude[i], CELL_TOWERlatitude[i], CELL_TOWERtimeStamp[i], 
					CELL_TOWERmcc[i], CELL_TOWERmnc[i], CELL_TOWERlac[i], CELL_TOWERcid[i], 
					CELL_TOWERnid[i], CELL_TOWERbid[i], CELL_TOWERsid[i])
			
			if uuid != '':
				self.__generateTraceRelation(self.DEVICE_uuid, uuid, 'Connected_To', 
				'', '', CELL_TOWERtimeStamp[i], '')
				self.__generateChainOfEvidence(cell_tower_id, uuid)

	def writeChat(self, CHATid, CHATstatus, CHATsource, CHATpartyIdentifiers, CHATpartyNames, 
                CHATmsgIdentifiersFrom, CHATmsgNamesFrom, CHATmsgBodies, CHATmsgStatuses, CHATmsgOutcomes,
                CHATmsgTimeStamps, CHATmsgAttachmentFilenames, CHATmsgAttachmentUrls):		
		"""
		main parameters
			CHATpartyIdentifiers: 	list of Identifier of Participants
			CHATpartyNames:			list of name of Participants
			CHATmsgIdentifiersFrom:	list of From Identifier of each  Message (1 per Message)
			CHATmsgNamesFrom:		list of From Name of each  Message (1 for Message)
			CHATmsgBodies:			list of Body of each Message
			CHATmsgAttachmentFilenames: list of Filename Attached to each Message (more than 1)
			CHATmsgAttachmentUrls		list of Url of the Filename Attached 
		"""

		for i, chat_id in enumerate(CHATid):			
			appSource = CHATsource[i].strip().lower()
			idAppIdentity = self.__checkAppName(appSource)
			
			CHATid_account_to = []
			CHATid_account_from = ''
#---	if the CHAT doesn't have Participants, it is disregarded
#
			if len(CHATpartyIdentifiers[i]) == 0:
#---	ignored, no Participants
#				
				continue

			for j, chat_party_id in enumerate(CHATpartyIdentifiers[i]):	
				idChatAccount = self.__checkChatParticipant(chat_party_id, 
					CHATpartyNames[i][j], CHATsource[i], idAppIdentity)				
#---	in the account_to list, also the CHATmsgIdentifiersFrom is added 					
#						
				CHATid_account_to.append(idChatAccount)			
			
			CHATthread = []
#---	CHATmsgBodies[i] is the list of the messages of the same thread, 
#		the j index iterates over all the messages within the i-th CHAT 
#			
			for j, chat_msg_body in enumerate(CHATmsgBodies[i]):	

				CHATmsgFrom = CHATmsgIdentifiersFrom[i][j].strip()
				if len(CHATmsgIdentifiersFrom[i]) > 0:
					CHATid_account_from = self.__checkChatParticipant(CHATmsgFrom,
						CHATmsgNamesFrom[i][j], CHATsource[i], idAppIdentity)	
				else:
					CHATid_account_from = self.__checkChatParticipant('MSG_IDENTIFIER_EMPTY',
						'MSG_NAME_EMPTY', CHATsource[i], idAppIdentity)				

				chatUuid = self.__generateTraceChat(chat_msg_body, idAppIdentity, 
					CHATmsgTimeStamps[i][j], CHATid_account_from, CHATid_account_to, 
					CHATmsgStatuses[i][j], CHATmsgOutcomes[i][j],
					'', CHATmsgAttachmentFilenames[i][j], 
					CHATmsgAttachmentUrls[i][j])

				CHATthread.append(chatUuid)
				if CHATmsgAttachmentFilenames[i][j].strip() != '':
					CHATattachmentFiles = CHATmsgAttachmentFilenames[i][j].split('###')
					for idx, chat_attachment_file in enumerate(CHATattachmentFiles):
						for key in self.FILEpath:						
							if self.FILEpath[key].find(chat_attachment_file) > - 1:
								self.__generateTraceRelation(self.FILEuuid[key], 
									chatUuid, 'Attached_To', '', '', '', '');
								break			

#---	if there are not messages for this Chat or no ChatAccount has been generated, 
#		the ThreadMessage is skipped and the Chain of evidence is ignored 
#			
			if (len(CHATthread) == 0) or (len(CHATid_account_to) == 0):
				pass
			else:
				uuidThread = self.__generateThreadMessages(chat_id, CHATthread, 
								CHATid_account_to)
				self.__generateChainOfEvidence(chat_id, uuidThread)

	def writeCookie(self, COOKIEid, COOKIEstatus, COOKIEsource, COOKIEname,
                    COOKIEvalue, COOKIEdomain, COOKIEcreationTime, COOKIElastAccessTime, 
                    COOKIEexpiry):
		for i, cookie_id in enumerate(COOKIEid):
			uuid= self.__generateTraceCookie(cookie_id, COOKIEstatus[i], 
					COOKIEsource[i], COOKIEname[i], COOKIEvalue[i], 
					COOKIEdomain[i], COOKIEcreationTime[i], COOKIElastAccessTime[i], 
					COOKIEexpiry[i])
			
			self.__generateChainOfEvidence(cookie_id, uuid)

	def writeDeviceEvent(self, DEVICE_EVENTid, DEVICE_EVENTstatus, 
                    DEVICE_EVENTtimeStamp, DEVICE_EVENTeventType, DEVICE_EVENTvalue):

		for i, device_event_id in enumerate(DEVICE_EVENTid):
			uuid= self.__generateTraceDeviceEvent(device_event_id, DEVICE_EVENTstatus[i], 
					DEVICE_EVENTtimeStamp[i], DEVICE_EVENTeventType[i], DEVICE_EVENTvalue[i])
			
			self.__generateChainOfEvidence(device_event_id, uuid)

	def writeEmail(self, EMAILid, EMAILstatus, EMAILsource, EMAILidentifierFROM, 
				EMAILidentifiersTO, EMAILidentifiersCC, EMAILidentifiersBCC, 
                EMAILbody, EMAILsubject, EMAILtimeStamp, EMAILattachmentsFilename):
		for i, email_id in enumerate(EMAILid):
			self.__generateTraceEmail(email_id, EMAILstatus[i], EMAILsource[i],
				EMAILidentifierFROM[i], EMAILidentifiersTO[i], 
				EMAILidentifiersCC[i], EMAILidentifiersBCC[i], EMAILbody[i], 
				EMAILsubject[i], EMAILtimeStamp[i], EMAILattachmentsFilename[i])


	def writeInstantMessage(self, INSTANT_MSGid, INSTANT_MSGstatus, INSTANT_MSGsource, 
			INSTANT_MSGtimeStamp, INSTANT_MSGfromIdentifier, INSTANT_MSGfromName,
            INSTANT_MSGtoIdentifier, INSTANT_MSGtoName, INSTANT_MSGsubject, INSTANT_MSGbody, 
            INSTANT_MSGfolder, INSTANT_MSGtype, INSTANT_MSGapplication):
		
		for i, i_msg_id in enumerate(INSTANT_MSGid):			
			if INSTANT_MSGsource[i].find('Native') > -1:
				idx = self.appNameList.index("Native")
				id_app_name = self.appIDList[idx]
			else:
				if INSTANT_MSGsource[i].strip() in self.appNameList: 
					idx = self.appNameList.index(INSTANT_MSGsource[i].strip())
					id_app_name = self.appIDList[idx]
				else:
					id_app_name = self.__generateTraceAppName(INSTANT_MSGsource[i].strip())
					self.appNameList.append(INSTANT_MSGsource[i].strip())
					self.appIDList.append(id_app_name)	

			i_msg_from_identifier = INSTANT_MSGfromIdentifier[i].strip()
			
			if  i_msg_from_identifier != '' :
				if i_msg_from_identifier in self.phoneNumberList:						
					idx = self.phoneNumberList.index(i_msg_from_identifier)
					i_msg_from_id = self.phoneUuidList[idx]
				else:
					self.phoneNumberList.append(i_msg_from_identifier)
					self.phoneNameList.append(INSTANT_MSGfromName[i])
					mobileOperator = ""
					i_msg_from_id = self.__generateTracePhoneAccount(mobileOperator, 
							INSTANT_MSGfromName[i], i_msg_from_identifier)	
					self.phoneUuidList.append(i_msg_from_id)
			else:
				i_msg_from_id = ''
			
			list_TO = INSTANT_MSGtoIdentifier[i].split('@@@')
			i_msg_to_ids = ''
			for j, item in enumerate(list_TO):
				if item.strip() != '':
					if item in self.phoneNumberList:						
						idx = self.phoneNumberList.index(item.strip())
						i_msg_to_id = self.phoneUuidList[idx]												
					else:
						self.phoneNumberList.append(item.strip())
						self.phoneNameList.append(INSTANT_MSGtoName[i])
						mobileOperator = ""
						i_msg_to_id = self.__generateTracePhoneAccount(mobileOperator, 
						INSTANT_MSGtoName[i], item.strip())	
						self.phoneUuidList.append(i_msg_to_id)
					i_msg_to_ids += '{"@id":"' + i_msg_to_id + '"},'


			if i_msg_to_ids != '':
				i_msg_to_ids = i_msg_to_ids[:-1] # get rid of comma
						
			uuid = self.__generateTraceMessageFacet(INSTANT_MSGbody[i], id_app_name, 
				i_msg_from_id, i_msg_to_ids, INSTANT_MSGtimeStamp[i], INSTANT_MSGstatus[i], 
				'Instant Message')			
			
			if uuid != '':
				self.__generateChainOfEvidence(i_msg_id, uuid)

	def writeLocationDevice(self, LOCATIONid, LOCATIONstatus, LOCATIONlongitude, 
					LOCATIONlatitude, LOCATIONaltitude, LOCATIONtimeStamp, 
					LOCATIONcategory):
		    
		for i, location_id in enumerate(LOCATIONid):
			uuid= self.__generateTraceLocationDevice(location_id, LOCATIONstatus[i], 
					LOCATIONlongitude[i], LOCATIONlatitude[i], LOCATIONaltitude[i],
					LOCATIONtimeStamp[i], LOCATIONcategory[i])
			
			if uuid != '':
				self.__generateTraceRelation(self.DEVICE_uuid, uuid, 'Mapped_By', 
				'', '', LOCATIONtimeStamp[i], '')
				self.__generateChainOfEvidence(location_id, uuid)


	def writeSocial_Media(self, SOCIAL_MEDIAid, SOCIAL_MEDIAstatus, 
            SOCIAL_MEDIAsource, SOCIAL_MEDIAtimeStamp, 
            SOCIAL_MEDIAbody, SOCIAL_MEDIAtitle, SOCIAL_MEDIAurl, SOCIAL_MEDIAidentifier, 
            SOCIAL_MEDIAname, SOCIAL_MEDIAreactionsCount, SOCIAL_MEDIAsharesCount,
            SOCIAL_MEDIAactivityType, SOCIAL_MEDIAcommentCount,
            SOCIAL_MEDIAaccount):

		for i, social_media_item_id in enumerate(SOCIAL_MEDIAid):
			uuid= self.__generateTraceSocialMedia_Item(social_media_item_id, SOCIAL_MEDIAstatus[i], 
					SOCIAL_MEDIAsource[i], SOCIAL_MEDIAtimeStamp[i], SOCIAL_MEDIAbody[i],
					SOCIAL_MEDIAtitle[i], SOCIAL_MEDIAurl[i], SOCIAL_MEDIAidentifier[i],
					SOCIAL_MEDIAname[i], SOCIAL_MEDIAreactionsCount[i], SOCIAL_MEDIAsharesCount[i],
					SOCIAL_MEDIAactivityType[i], SOCIAL_MEDIAcommentCount[i], SOCIAL_MEDIAaccount[i])
			
			if uuid != '':
				self.__generateChainOfEvidence(social_media_item_id, uuid)

	def writeSearched_Item(self, SEARCHED_ITEMid, SEARCHED_ITEMstatus, SEARCHED_ITEMsource, 
					SEARCHED_ITEMtimeStamp, SEARCHED_ITEMvalue, SEARCHED_ITEMsearchResult):
		
		for i, search_item_id in enumerate(SEARCHED_ITEMid):
			uuid= self.__generateTraceSearched_Item(search_item_id, SEARCHED_ITEMstatus[i], 
					SEARCHED_ITEMsource[i], SEARCHED_ITEMtimeStamp[i], SEARCHED_ITEMvalue[i],
					SEARCHED_ITEMsearchResult[i])
			
			if uuid != '':
				self.__generateChainOfEvidence(search_item_id, uuid)

	def writeWebPages(self, WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited):
		self.__generateTraceWebPages(WEB_PAGEid, WEB_PAGEstatus, WEB_PAGEsource, WEB_PAGEurl, 
				WEB_PAGEtitle, WEB_PAGEvisitCount,  WEB_PAGlastVisited)

	def writeWireless_Net(self, WIRELESS_NETid, WIRELESS_NETstatus, WIRELESS_NETlongitude, 
					WIRELESS_NETlatitude, WIRELESS_NETtimeStamp, WIRELESS_NETlastConnection,
                    WIRELESS_NETbssid, WIRELESS_NETssid):
		
		for i, wireless_net_id in enumerate(WIRELESS_NETid):
			uuid= self.__generateTraceWireless_Net(wireless_net_id, WIRELESS_NETstatus[i], 
					WIRELESS_NETlongitude[i], WIRELESS_NETlatitude[i], WIRELESS_NETtimeStamp[i], 
					WIRELESS_NETlastConnection[i], WIRELESS_NETbssid[i], WIRELESS_NETssid[i])
			
			if uuid != '':
				self.__generateTraceRelation(self.DEVICE_uuid, uuid, 'Connected_To', 
					'', '', WIRELESS_NETtimeStamp[i], WIRELESS_NETlastConnection[i])
				self.__generateChainOfEvidence(wireless_net_id, uuid)

	def writeSms(self, SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles,
					SMSpartyIdentifiers, SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource):
		self.__generateTraceSms(SMSid, SMSstatus, SMStimeStamp, SMSpartyRoles, 
					SMSpartyIdentifiers, SMSsmsc, SMSpartyNames, SMSfolder, SMSbody, SMSsource)

	def writeContextUfed(self, ufedVersionText, deviceReportCreateTime,
		deviceExtractionStartTime, deviceExtractionEndTime, examinerNameText,
		imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5):

		self.__generateContextUfed(ufedVersionText, deviceReportCreateTime,
			deviceExtractionStartTime, deviceExtractionEndTime, examinerNameText, 
			imagePath, imageSize, imageMetadataHashSHA, imageMetadataHashMD5)


